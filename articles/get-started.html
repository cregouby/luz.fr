<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="fr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Bien démarrer avec luz • luz.fr</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Bien démarrer avec luz">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Passer au contenu</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Navigation sur le site"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">luz.fr</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.4.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Activer la navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><h6 class="dropdown-header" data-toc-skip>Utiliser luz</h6></li>
    <li><a class="dropdown-item" href="../articles/get-started.html">Bien démarrer</a></li>
    <li><a class="dropdown-item" href="../articles/custom-loop.html">Boucles personnalisées</a></li>
    <li><a class="dropdown-item" href="../articles/accelerator.html">l'API des périphériques d'accélération</a></li>
    <li><h6 class="dropdown-header" data-toc-skip>Guides</h6></li>
    <li><a class="dropdown-item" href="../articles/lr-finder.html">Recherche du taux d'apprentissage avec lr_finder</a></li>
    <li><a class="dropdown-item" href="../articles/checkpoints.html">Instantannés de modèles</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../articles/examples/index.html">Examples</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Référence</a></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changements</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/cregouby/luz.fr/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Bien démarrer avec luz</h1>
            
      
      <small class="dont-index">Source : <a href="https://github.com/cregouby/luz.fr/blob/HEAD/vignettes/get-started.Rmd" class="external-link"><code>vignettes/get-started.Rmd</code></a></small>
      <div class="d-none name"><code>get-started.Rmd</code></div>
    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://mlverse.github.io/luz/" class="external-link">luz</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://torch.mlverse.org/docs" class="external-link">torch</a></span><span class="op">)</span></span></code></pre></div>
<p>Luz est une API de haut niveau pour torch qui vise à encapsuler la
<strong>boucle d’entraînement</strong> dans un ensemble de blocs de code
réutilisables. Luz réduit le code de gestion requis pour former un
modèle avec torch et évite les erreurs fréquentes sur la séquence des
appels à <code>zero_grad()</code> - <code>backward()</code> -
<code><a href="https://rdrr.io/r/stats/step.html" class="external-link">step()</a></code>, et simplifie également le processus de déplacement
des données et des modèles entre les CPUs et la GPU. Luz est conçu pour
être très flexible en fournissant une API en couches qui lui permet
d’être utile quel que soit le niveau de contrôle dont vous avez besoin
pour votre boucle d’entraînement.</p>
<p>Luz est fortement inspiré par d’autres framework de haut-niveau pour
l’apprentissage profond, pour citer quelques-uns:</p>
<ul>
<li><p><a href="https://docs.fast.ai/" class="external-link">FastAI</a>: nous avons été
fortement inspirés par la bibliothèque FastAI, en particulier l’objet
<code>Learner</code> et l’API callbacks.</p></li>
<li><p><a href="https://keras.io/" class="external-link">Keras</a>: Nous sommes également
fortement inspirés par Keras, en particulier les noms de callback.
L’interface du module <code>lightning</code> est aussi similaire à
<code>compile</code>.</p></li>
<li><p><a href="https://lightning.ai/pages/open-source/" class="external-link">PyTorch
Lightning</a>: L’idée que le <code>luz_module</code> soit une
sous-classe de <code>nn_module</code> s’inspire de l’objet
<strong><code>LightningModule</code></strong> dans la
<code>lightning</code>.</p></li>
<li><p><a href="https://huggingface.co/docs/accelerate/" class="external-link">HuggingFace
Accelerate</a>: L’API interne de placement sur les périphériques de
calcul est fortement inspirée par Accelerate, mais est beaucoup plus
modeste dans les fonctionnalités.</p></li>
</ul>
<div class="section level2">
<h2 id="entraînement-dun-nn_module">Entraînement d’un <code>nn_module</code><a class="anchor" aria-label="anchor" href="#entra%C3%AEnement-dun-nn_module"></a>
</h2>
<p>Luz tente, autant que possible, de réutiliser les structures
existantes de torch. Un modèle en luz est défini de la même manière que
vous le définiriez si vous utilisez torch brut. Par exemple, voici la
définition d’un CNN feed-forward qui peut être utilisé pour classer les
chiffres de l’ensemble de données MNIST:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">net</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/torch/man/nn_module.html" class="external-link">nn_module</a></span><span class="op">(</span></span>
<span>  <span class="st">"Net"</span>,</span>
<span>  initialize <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">num_class</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">self</span><span class="op">$</span><span class="va">conv1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/torch/man/nn_conv2d.html" class="external-link">nn_conv2d</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">32</span>, <span class="fl">3</span>, <span class="fl">1</span><span class="op">)</span></span>
<span>    <span class="va">self</span><span class="op">$</span><span class="va">conv2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/torch/man/nn_conv2d.html" class="external-link">nn_conv2d</a></span><span class="op">(</span><span class="fl">32</span>, <span class="fl">64</span>, <span class="fl">3</span>, <span class="fl">1</span><span class="op">)</span></span>
<span>    <span class="va">self</span><span class="op">$</span><span class="va">dropout1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/torch/man/nn_dropout2d.html" class="external-link">nn_dropout2d</a></span><span class="op">(</span><span class="fl">0.25</span><span class="op">)</span></span>
<span>    <span class="va">self</span><span class="op">$</span><span class="va">dropout2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/torch/man/nn_dropout2d.html" class="external-link">nn_dropout2d</a></span><span class="op">(</span><span class="fl">0.5</span><span class="op">)</span></span>
<span>    <span class="va">self</span><span class="op">$</span><span class="va">fc1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/torch/man/nn_linear.html" class="external-link">nn_linear</a></span><span class="op">(</span><span class="fl">9216</span>, <span class="fl">128</span><span class="op">)</span></span>
<span>    <span class="va">self</span><span class="op">$</span><span class="va">fc2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/torch/man/nn_linear.html" class="external-link">nn_linear</a></span><span class="op">(</span><span class="fl">128</span>, <span class="va">num_class</span><span class="op">)</span></span>
<span>  <span class="op">}</span>,</span>
<span>  forward <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">x</span> <span class="op">&lt;-</span> <span class="va">self</span><span class="op">$</span><span class="fu">conv1</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>    <span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/torch/man/nnf_relu.html" class="external-link">nnf_relu</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>    <span class="va">x</span> <span class="op">&lt;-</span> <span class="va">self</span><span class="op">$</span><span class="fu">conv2</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>    <span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/torch/man/nnf_relu.html" class="external-link">nnf_relu</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>    <span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/torch/man/nnf_max_pool2d.html" class="external-link">nnf_max_pool2d</a></span><span class="op">(</span><span class="va">x</span>, <span class="fl">2</span><span class="op">)</span></span>
<span>    <span class="va">x</span> <span class="op">&lt;-</span> <span class="va">self</span><span class="op">$</span><span class="fu">dropout1</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>    <span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/torch/man/torch_flatten.html" class="external-link">torch_flatten</a></span><span class="op">(</span><span class="va">x</span>, start_dim <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span>    <span class="va">x</span> <span class="op">&lt;-</span> <span class="va">self</span><span class="op">$</span><span class="fu">fc1</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>    <span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/torch/man/nnf_relu.html" class="external-link">nnf_relu</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>    <span class="va">x</span> <span class="op">&lt;-</span> <span class="va">self</span><span class="op">$</span><span class="fu">dropout2</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>    <span class="va">x</span> <span class="op">&lt;-</span> <span class="va">self</span><span class="op">$</span><span class="fu">fc2</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>    <span class="va">x</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Nous pouvons maintenant entraîner ce modèle dans le
<code>train_dl</code> et l’évaluer dans le
<code>torch::dataloaders()</code> nomé <code>test_dl</code> avec:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fitted</span> <span class="op">&lt;-</span> <span class="va">net</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span></span>
<span>  <span class="fu"><a href="../reference/setup.html">setup</a></span><span class="op">(</span></span>
<span>    loss <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/torch/man/nn_cross_entropy_loss.html" class="external-link">nn_cross_entropy_loss</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>    optimizer <span class="op">=</span> <span class="va">optim_adam</span>,</span>
<span>    metrics <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span>
<span>      <span class="va">luz_metric_accuracy</span></span>
<span>    <span class="op">)</span></span>
<span>  <span class="op">)</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span></span>
<span>  <span class="fu"><a href="../reference/set_hparams.html">set_hparams</a></span><span class="op">(</span>num_class <span class="op">=</span> <span class="fl">10</span><span class="op">)</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu"><a href="../reference/set_opt_hparams.html">set_opt_hparams</a></span><span class="op">(</span>lr <span class="op">=</span> <span class="fl">0.003</span><span class="op">)</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu"><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit</a></span><span class="op">(</span><span class="va">train_dl</span>, epochs <span class="op">=</span> <span class="fl">10</span>, valid_data <span class="op">=</span> <span class="va">test_dl</span><span class="op">)</span></span></code></pre></div>
<p>Voyons en détail ce qui se passe dans ce bloc de code :</p>
<ol style="list-style-type: decimal">
<li>La fonction <code>setup</code> vous permet de configurer la fonction
de coût (objectif) et l’optimiseur que vous utiliserez pour entraîner
votre modèle. En option, vous pouvez passer une liste de métriques qui
sont suivies pendant la procédure d’apprentissage.
<strong>Remarque</strong> : la fonction de coût peut être n’importe
quelle fonction prenant en entrée <code>input</code> et
<code>target</code> et retournant une valeur de tenseur scalaire, et
l’optimiseur peut être n’importe quel optimiseur de torch natif ou
personnalisé, créé avec la fonction
<code><a href="https://rdrr.io/pkg/torch/man/optimizer.html" class="external-link">torch::optimizer()</a></code>.</li>
<li>La fonction <code><a href="../reference/set_hparams.html">set_hparams()</a></code> permet de définir les
hyper-paramètres qui doivent être passées à la méthode
<code>initialize()</code> du module. Par exemple dans ce cas nous
passons <code>num_classes = 10</code>.</li>
<li>La fonction <code><a href="../reference/set_opt_hparams.html">set_opt_hparams()</a></code> vous permet de passer des
hyper-paramètres utilisés par la fonction d’optimisation. Par exemple,
<code><a href="https://rdrr.io/pkg/torch/man/optim_adam.html" class="external-link">optim_adam()</a></code> peut prendre le paramètre <code>lr</code>
spécifiant le taux d’apprentissage et nous le spécifions avec
<code>lr = 0.003</code>.</li>
<li>La méthode <code>fit</code> va prendre les spécifications du modèle
fournies par <code><a href="../reference/setup.html">setup()</a></code> et exécuter le processus
d’apprentissage en utilisant les jeux de donnée d’entraînement et de
validation spécifiés dans des <code>torch::dataloaders()</code> ainsi
que le nombre d’époques. <strong>Remarque</strong> : nous réutilisons
les structures de données de base de torch pour les chargeurs de donnée,
au lieu de recréer notre propre fonctionnalité de chargement de
données.</li>
<li>L ’ objet retourné <code>fitted</code> contient le modèle entraîné
ainsi que le registre de métriques et de pertes produites au cours de
l’apprentissage. Il peut également être utilisé pour la production de
prédictions et l’évaluation du modèle entraîné sur d’autres jeux de
données.</li>
</ol>
<p>Au moment du déploiement du calcul, luz utilisera l’accélérateur le
plus rapide possible; si un GPU doté de CUDA est disponible, il sera
utilisé, sinon le calcul sera affecté sur la CPU. Il déplace également
automatiquement les données, les optimisateurs et les modèles vers le
périphérique sélectionné afin que vous n’ayez pas besoin de les
manipuler manuellement (qui constitue une grande source d’erreurs en
général).</p>
<p>Pour créer des prédictions à partir du modèle entraîné, vous pouvez
utiliser la méthode <code>predict</code>:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">predictions</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">fitted</span>, <span class="va">test_dl</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="la-boucle-dentraînement">La boucle d’entraînement<a class="anchor" aria-label="anchor" href="#la-boucle-dentra%C3%AEnement"></a>
</h2>
<p>Maintenant que vous avez une idée générale de la façon d’utiliser la
fonction <code>fit</code>, il est important d’avoir un aperçu de ce qui
se passe à l’intérieur. Voici ce que <code>fit</code> exécute (en
pseudocode). Ce n’est pas détaillé complètement, mais celà devrait vous
aider à construire votre intuition:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># -&gt; Initialiser les objets : modèle, optimiseurs.</span></span>
<span><span class="co"># -&gt; Sélectionner le périphérique d'apprentissage.</span></span>
<span><span class="co"># -&gt; Déplacer les données, le modèle et les optimiseurs vers le dispositif sélectionné.</span></span>
<span><span class="co"># -&gt; Lancer l'apprentissage</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">epoch</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">epochs</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># -&gt; Procédure d'apprentissage</span></span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">batch</span> <span class="kw">in</span> <span class="va">train_dl</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="co"># -&gt; Calculer la méthode `forward` du modèle.</span></span>
<span>    <span class="co"># -&gt; Calculer la perte.</span></span>
<span>    <span class="co"># -&gt; Mettre à jour les poids.</span></span>
<span>    <span class="co"># -&gt; Mettre à jour les métriques et suivre la perte.</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="co"># -&gt; Procédure de validation</span></span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">batch</span> <span class="kw">in</span> <span class="va">valid_dl</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="co"># -&gt; Calculer la méthode `forward` du modèle.</span></span>
<span>    <span class="co"># -&gt; Calculer la perte.</span></span>
<span>    <span class="co"># -&gt; Mettre à jour les métriques et suivre la perte.</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span><span class="co"># -&gt; Fin de l'apprentissage</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="les-métriques">Les métriques<a class="anchor" aria-label="anchor" href="#les-m%C3%A9triques"></a>
</h2>
<p>L’une des parties les plus importantes des projets d’apprentissage
automatique est le choix de la métrique d’évaluation. Luz permet de
suivre de nombreuses métriques différentes pendant l’apprentissage avec
des changements de code minimes.</p>
<p>Pour suivre les métriques, il suffit de modifier le paramètre
<code>metrics</code> dans la fonction <code>setup</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>fitted <span class="ot">&lt;-</span> net <span class="sc">%&gt;%</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>  <span class="fu">setup</span>(</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>    ...</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>    <span class="at">metrics =</span> <span class="fu">list</span>(</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>      luz_metric_accuracy</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>    )</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>  <span class="fu">fit</span>(...)</span></code></pre></div>
<p>Luz fournit des implémentations de quelques-unes des métriques les
plus utilisées. Si une métrique n’est pas disponible, vous pouvez
toujours la mettre en place à l’aide de la fonction
<code>luz_metric</code>.</p>
<p>Pour implémenter une nouvelle métrique <code>luz_metric</code>, il
faut définir 3 méthodes :</p>
<ul>
<li><p><code>initialize</code> : définit l’état initial de la métrique.
Cette fonction est appelée à chaque époque pour les boucles
d’entraînement et de validation.</p></li>
<li><p><code>update</code> : met à jour l’état interne de la métrique.
Cette fonction est appelée à chaque étape d’entraînement et de
validation avec les prédictions obtenues par le modèle et les valeurs
cibles renvoyées par le chargeur de données.</p></li>
<li><p><code>compute</code> : utilise l’état interne pour calculer les
valeurs de la métrique. Cette fonction est appelée toutes les fois où il
faut obtenir la valeur actuelle de la métrique. Par exemple, elle est
appelée à chaque étape d’entraînement pour afficher les informations de
progression, mais seulement appelée une fois par époque pour enregistrer
sa valeur lorsqu’il n’y a pas de barre de progression.</p></li>
</ul>
<p>Vous pouvez définir un champ optionnel <code>abbrev</code> qui donne
à la métrique une abréviation utilisée lors de l’affichage des
informations de métrique dans la console ou dans les enregistrements. Si
aucune valeur n’est fournie pour <code>abbrev</code>, le nom de classe
de la métrique est utilisé.</p>
<p>Essayons maintenant de voir l’implémentation de
<code>luz_metric_accuracy</code> pour mettre en œuvre une nouvelle
métrique :</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">luz_metric_accuracy</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/luz_metric.html">luz_metric</a></span><span class="op">(</span></span>
<span>  <span class="co"># Une abréviation à afficher dans les barres de progression ou </span></span>
<span>  <span class="co"># lors de l'affichage des informations de progression</span></span>
<span>  abbrev <span class="op">=</span> <span class="st">"Acc"</span>, </span>
<span>  <span class="co"># Initialisation pour la métrique. Les métriques sont initialisées</span></span>
<span>  <span class="co"># à chaque époque, pour les entraînements et les validations.</span></span>
<span>  initialize <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">self</span><span class="op">$</span><span class="va">correct</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>    <span class="va">self</span><span class="op">$</span><span class="va">total</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="op">}</span>,</span>
<span>  <span class="co"># Mise à jour à chaque étape d'entraînement ou de validation.</span></span>
<span>  <span class="co"># La fonction update prend `preds` </span></span>
<span>  <span class="co"># et `target` en paramètres et met à jour l'état interne `self`.</span></span>
<span>  update <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">preds</span>, <span class="va">target</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">pred</span> <span class="op">&lt;-</span> <span class="fu">torch</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/torch/man/torch_argmax.html" class="external-link">torch_argmax</a></span><span class="op">(</span><span class="va">preds</span>, dim <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span>    <span class="va">self</span><span class="op">$</span><span class="va">correct</span> <span class="op">&lt;-</span> <span class="va">self</span><span class="op">$</span><span class="va">correct</span> <span class="op">+</span> <span class="op">(</span><span class="va">pred</span> <span class="op">==</span> <span class="va">target</span><span class="op">)</span><span class="op">$</span></span>
<span>      <span class="fu">to</span><span class="op">(</span>dtype <span class="op">=</span> <span class="fu">torch</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/torch/man/torch_dtype.html" class="external-link">torch_float</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span><span class="op">$</span></span>
<span>      <span class="fu">sum</span><span class="op">(</span><span class="op">)</span><span class="op">$</span></span>
<span>      <span class="fu">item</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="va">self</span><span class="op">$</span><span class="va">total</span> <span class="op">&lt;-</span> <span class="va">self</span><span class="op">$</span><span class="va">total</span> <span class="op">+</span> <span class="va">pred</span><span class="op">$</span><span class="fu">numel</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="op">}</span>,</span>
<span>  <span class="co"># Utilise l'état interne pour demander la valeur de la métrique.</span></span>
<span>  compute <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">self</span><span class="op">$</span><span class="va">correct</span><span class="op">/</span><span class="va">self</span><span class="op">$</span><span class="va">total</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p><strong>Remarque</strong>: Il est préférable que la fonction
<code>compute</code> retourne des valeurs R régulières plutôt
qu’éventuellement des tenseurs torch. D’autres parties de luz
s’attendent à cela et s’y attacheront.</p>
</div>
<div class="section level2">
<h2 id="évaluation">Évaluation<a class="anchor" aria-label="anchor" href="#%C3%A9valuation"></a>
</h2>
<p>Une fois un modèle entraîné, vous voulez peut-être évaluer sa
performance sur un autre jeu de données. Pour cela, luz fournit la
fonction <code><a href="../reference/evaluate.html">?evaluate</a></code> qui prend, en entrée, un modèle ajusté
et un jeu de données et calcule les métriques attachées au modèle.</p>
<p>L’opération <code><a href="../reference/evaluate.html">evaluate()</a></code> retourne un objet
<code>luz_module_evaluation</code> que vous pouvez interroger pour des
métriques à l’aide de la fonction <code><a href="../reference/get_metrics.html">get_metrics()</a></code> ou
simplement imprimer pour voir les résultats.</p>
<p>Par exemple :</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">evaluation</span> <span class="op">&lt;-</span> <span class="va">fitted</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span> <span class="fu"><a href="../reference/evaluate.html">evaluate</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">valid_dl</span><span class="op">)</span></span>
<span><span class="va">metrics</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get_metrics.html">get_metrics</a></span><span class="op">(</span><span class="va">evaluation</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">evaluation</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">#&gt; A `luz_module_evaluation`</span></span>
<span><span class="co">#&gt; -- Results ---------------------------------------------------------------------</span></span>
<span><span class="co">#&gt; loss: 1.8892</span></span>
<span><span class="co">#&gt; mae: 1.0522</span></span>
<span><span class="co">#&gt; mse: 1.645</span></span>
<span><span class="co">#&gt; rmse: 1.2826</span></span></code></pre>
</div>
<div class="section level2">
<h2 id="personnalisation-avec-les-callbacks">Personnalisation avec les callbacks<a class="anchor" aria-label="anchor" href="#personnalisation-avec-les-callbacks"></a>
</h2>
<p>Luz fournit différentes façons de personnaliser la boucle
d’apprentissage, en fonction du niveau de contrôle dont vous avez besoin
pendant qu’elle s’exécute. La façon la plus rapide et la plus «
réutilisable » est via les <strong>callbacks</strong>. Ils permettent de
créer des modifications d’apprentissage qui peuvent être utilisées dans
de nombreuses situations.</p>
<p>La boucle d’apprentissage en luz a de nombreux <em>points
d’arrêt</em> qui peuvent appeler des fonctions R arbitraires. Cette
fonctionnalité vous permet de personnaliser le processus d’apprentissage
sans avoir à modifier la logique générale de l’apprentissage.</p>
<p>Luz implémente 3 callbacks par défaut qui se produisent dans chaque
procédure d’apprentissage :</p>
<ul>
<li><p><strong>callback train-eval</strong>: Bascule le modèle en
<code>train()</code> ou <code><a href="https://rdrr.io/r/base/eval.html" class="external-link">eval()</a></code> selon si la procédure est en
cours de d’entraînement ou de validation.</p></li>
<li><p><strong>callback metrics</strong> : évaluer les paramètres au
cours du processus d’entraînement et de validation.</p></li>
<li><p><strong>callback progress</strong> : implémente une barre de
progression et imprime des informations sur la progression pendant
l’apprentissage.</p></li>
</ul>
<p>Vous pouvez également mettre en place des callbacks personnalisés qui
modifient ou agissent spécifiquement pour votre procédure
d’apprentissage. Par exemple:</p>
<p>Implémentons un callback qui imprime ‘Itération <code>n</code>’ (où
<code>n</code> est le numéro d’itération) pour chaque batch dans le jeu
de données d’apprentissage et ‘Fini!’ lorsque la fin d’une époque est
atteinte.</p>
<p>Pour cela, nous utilisons la fonction <code><a href="../reference/luz_callback.html">luz_callback()</a></code>
:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">print_callback</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/luz_callback.html">luz_callback</a></span><span class="op">(</span></span>
<span>  name <span class="op">=</span> <span class="st">"print_callback"</span>,</span>
<span>  initialize <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">message</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">self</span><span class="op">$</span><span class="va">message</span> <span class="op">&lt;-</span> <span class="va">message</span></span>
<span>  <span class="op">}</span>,</span>
<span>  on_train_batch_end <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="st">"Itération "</span>, <span class="va">ctx</span><span class="op">$</span><span class="va">iter</span>, <span class="st">"\n"</span><span class="op">)</span></span>
<span>  <span class="op">}</span>,</span>
<span>  on_epoch_end <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="va">self</span><span class="op">$</span><span class="va">message</span>, <span class="st">"\n"</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p><code><a href="../reference/luz_callback.html">luz_callback()</a></code> prend des fonctions nommées en argument
<code>...</code>, où le nom indique le moment auquel le callback doit
être appelé. Par exemple, <code>on_train_batch_end()</code> est appelé
pour chaque fin de batch lors du processus d’apprentissage, et
<code>on_epoch_end()</code> est appelé à la fin de chaque époque.</p>
<p>La valeur retournée par <code><a href="../reference/luz_callback.html">luz_callback()</a></code> est une fonction
qui initie une instance du callback. Les callbacks peuvent avoir besoin
de paramètres d’initialisation, comme le nom d’un fichier où vous
souhaitez logger les résultats. Dans ce cas, vous pouvez passer par une
méthode <code>initialize</code> lors de la définition du callback, et
sauvegarder ces paramètres dans l’objet <code>self</code>. Dans
l’exemple ci-dessus, le callback a un paramètre <code>message</code> qui
est imprimé à la fin de chaque épisode.</p>
<p>Une fois que le callback est défini, il peut être passé à la fonction
<code>fit</code> via le paramètre <code>callbacks</code> :</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fitted</span> <span class="op">&lt;-</span> <span class="va">net</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span></span>
<span>  <span class="fu"><a href="../reference/setup.html">setup</a></span><span class="op">(</span><span class="va">...</span><span class="op">)</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span></span>
<span>  <span class="fu"><a href="https://generics.r-lib.org/reference/fit.html" class="external-link">fit</a></span><span class="op">(</span><span class="va">...</span>, callbacks <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span>
<span>    <span class="fu">print_callback</span><span class="op">(</span>message <span class="op">=</span> <span class="st">"Fini!"</span><span class="op">)</span></span>
<span>  <span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Les callbacks peuvent être appelés à de nombreux endroits de la
boucle d’apprentissage, y compris en combinaison les uns avec les
autres. Voici un aperçu des endroits possibles pour insérer les
callbacks :</p>
<pre><code>Début de boucle d'ajustement
   - on_fit_begin
  Début de l'époque
     - on_epoch_begin
    Début de l'apprentissage
       - on_train_begin
      Début de la boucle de batch
         - on_train_batch_begin
          Début du pas d'apprentissage par défaut
            - on_train_batch_after_pred
            - on_train_batch_after_loss
            - on_train_batch_before_backward
            - on_train_batch_before_step
            - on_train_batch_after_step
          Fin du pas d'apprentissage par défaut :
         - on_train_batch_end
      Fin de la boucle de batch
       - on_train_end
    Fin de l'apprentissage
    Début de la validation
       - on_valid_begin
      Début de la boucle de batch
         - on_valid_batch_begin
          Début du pas de validation par défaut
            - on_valid_batch_after_pred
            - on_valid_batch_after_loss
          Fin du pas de validation par défaut
         - on_valid_batch_end
      Fin de la boucle de batch
       - on_valid_end
    Fin de la validation
      - on_epoch_end
  Fin de l'époque
   - on_fit_end
Fin de l'ajustement</code></pre>
<p>Chaque étape marquée avec <code>on_*</code> est un point dans le
processus d’apprentissage qui est disponible pour les callbacks pour
être appelés.</p>
<p>L’autre partie importante des callbacks est l’objet <code>ctx</code>
(contexte). Voir <code><a href="../reference/ctx.html">help("ctx")</a></code> pour plus de détails.</p>
<p>Par défaut, les callbacks sont appelés dans l’ordre dans lequel ils
ont été passés à <code>fit</code> (ou <code>predict</code> ou
<code>evaluate</code>), mais vous pouvez fournir un attribut
<code>weight</code> qui contrôlera l’ordre croissant dans lequel il sera
appelé. Par exemple, si un callback a <code>weight = 10</code> et un
autre a <code>weight = 1</code>, alors le premier est appelé après le
second. Les callbacks qui ne spécifient pas d’attribut de poids sont
considérés comme ayant un <code>weight = 0</code>. Certains callbacks
intégrés dans luz fournissent déjà une valeur de poids. Par exemple,
<code><a href="../reference/luz_callback_early_stopping.html">?luz_callback_early_stopping</a></code> a une valeur de poids de
<code>Inf</code>, puisque en général on souhaite l’exécuter à la toute
fin dans la boucle.</p>
<p>Notez que les callbacks peuvent être combinés pour effectuer des
opérations complexes sur le processus d’apprentissage.</p>
<p>La variable <code>ctx</code> est un objet utilisé dans luz pour
partager des informations entre le boucle d’entraînement et les
callbacks, les méthodes du modèle et les métriques. La table suivante
décrit les informations disponibles par défaut dans <code>ctx</code>.
D’autres rappels peuvent potentiellement modifier ces attributs ou en
ajouter de nouveaux.</p>
<!-- Il est recommandé d'utiliser l'éditeur visuel RStudio pour éditer cette table. -->
<table class="table">
<caption>Attributs du contexte</caption>
<colgroup>
<col width="18%">
<col width="81%">
</colgroup>
<thead><tr class="header">
<th>Attribut</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>verbose</code></td>
<td>La valeur (<code>TRUE</code> ou <code>FALSE</code>) attribuée à
l’argument <code>verbose</code> dans la fonction <code>fit</code>.</td>
</tr>
<tr class="even">
<td><code>accelerator</code></td>
<td>Objet accélérateur utilisé pour interroger le bon périphérique de
calcul (cuda, …) sur lequel placer les modèles, les données, etc. Il
repose sur la valeur passée au paramètre <code>accelerator</code> dans
<code>fit</code>.</td>
</tr>
<tr class="odd">
<td><code>model</code></td>
<td>Objet <code>nn_module</code> initialisé, qui sera entraîné pendant
la procédure <code>fit</code>.</td>
</tr>
<tr class="even">
<td><code>optimizers</code></td>
<td>Une liste nommée d’optimiseurs utilisés lors de l’entraînement.</td>
</tr>
<tr class="odd">
<td><code>data</code></td>
<td>Le chargeur de données actuellement en cours d’utilisation. Lors de
l’entraînement, c’est <code>ctx$train_data</code>, lors de la
validation, c’est <code>ctx$valid_data</code>. Il peut également s’agir
du jeu de données de prédiction lorsque dans <code>predict</code>.</td>
</tr>
<tr class="even">
<td><code>train_data</code></td>
<td>Chargeur de données passé à l’argument <code>data</code> dans
<code>fit</code>. Modifié pour produire des données sur le périphérique
de calcul sélectionné.</td>
</tr>
<tr class="odd">
<td><code>valid_data</code></td>
<td>Chargeur de données passé à l’argument <code>valid_data</code> dans
<code>fit</code>. Modifié pour produire des données sur le périphérique
de calcul sélectionné.</td>
</tr>
<tr class="even">
<td><code>min_epochs</code></td>
<td>Nombre minimum d’époques pendant lesquelles le modèle sera
entraîné.</td>
</tr>
<tr class="odd">
<td><code>max_epochs</code></td>
<td>Nombre maximum d’époques pendant lesquelles le modèle sera
entraîné.</td>
</tr>
<tr class="even">
<td><code>epoch</code></td>
<td>Époque actuelle de l’entraînement.</td>
</tr>
<tr class="odd">
<td><code>iter</code></td>
<td>Itération actuelle de l’entraînement. Elle est réinitialisée à
chaque époque et lorsque l’on passe de la phase d’apprentissage à la
validation.</td>
</tr>
<tr class="even">
<td><code>training</code></td>
<td>
<code>TRUE</code> si le modèle est en mode entraînement,
<code>FALSE</code> sinon. Voir également
<code><a href="../reference/luz_callback_train_valid.html">help("luz_callback_train_valid")</a></code>.</td>
</tr>
<tr class="odd">
<td><code>callbacks</code></td>
<td>Liste des rappels qui seront appelés pendant la procédure
d’entraînement. C’est l’union de la liste passée à l’argument
<code>callbacks</code> et des rappels par défaut.</td>
</tr>
<tr class="even">
<td><code>step</code></td>
<td>Closure qui sera utilisée pour faire une étape du modèle. Elle est
utilisée pour les deux phases : apprentissage et validation. Elle ne
prend pas d’arguments, mais peut accéder à la variable
<code>ctx</code>.</td>
</tr>
<tr class="odd">
<td><code>call_callbacks</code></td>
<td>Appeler les rappels par nom. Par exemple
<code>call_callbacks("on_train_begin")</code> appellera tous les rappels
qui fournissent des méthodes pour ce point.</td>
</tr>
<tr class="even">
<td><code>batch</code></td>
<td>Dernier lot obtenu par le chargeur de données. Un lot est une
liste() avec 2 éléments, l’un servant d’entrée et l’autre de
sortie.</td>
</tr>
<tr class="odd">
<td><code>input</code></td>
<td>Premier élément du dernier lot obtenu par le chargeur de données
actuel.</td>
</tr>
<tr class="even">
<td><code>target</code></td>
<td>Deuxième élément du dernier lot obtenu par le chargeur de données
actuel.</td>
</tr>
<tr class="odd">
<td><code>pred</code></td>
<td>Dernières prédictions obtenues par <code>ctx$model$forward</code>.
<strong>Remarque</strong> : il peut être potentiellement modifié par les
rappels précédemment appelés. On notera également qu’il ne sera pas
disponible si vous avez utilisé une étape d’entraînement
personnalisée.</td>
</tr>
<tr class="even">
<td><code>loss_fn</code></td>
<td>La fonction de coût active que l’on veut minimiser pendant
l’apprentissage.</td>
</tr>
<tr class="odd">
<td><code>loss</code></td>
<td>Dernière valeur de coût obtenue.</td>
</tr>
<tr class="even">
<td><code>handlers</code></td>
<td>Les gestionnaires actuels, c’est-à-dire les fonctions qui sont
appelées en cas d’erreur.</td>
</tr>
<tr class="odd">
<td><code>epoch_handlers</code></td>
<td>Liste des gestionnaires utilisés à l’intérieur de la boucle
d’époque. Ils peuvent être utilisés pour gérer des conditions
spécifiques aux époques, sans nécessairement mettre fin à
l’apprentissage.</td>
</tr>
</tbody>
</table>
<p>Les attributs de <code>ctx</code> peuvent être utilisés pour produire
le comportement souhaité des callbacks. Vous pouvez trouver de plus
amples informations sur l’objet de contexte à l’aide de
<code><a href="../reference/ctx.html">help("ctx")</a></code>. Dans notre exemple, nous utilisons l’attribut
<code>ctx$iter</code> pour imprimer le numéro d’itération pour chaque
lot d’apprentissage.</p>
</div>
<div class="section level2">
<h2 id="étapes-suivantes">Étapes suivantes<a class="anchor" aria-label="anchor" href="#%C3%A9tapes-suivantes"></a>
</h2>
<p>Dans cet article, vous avez appris à entraîner votre premier modèle
en utilisant luz et les bases de la personnalisation en utilisant à la
fois des métriques personnalisées et des callbacks.</p>
<p>Luz permet également des modifications plus flexibles du processus
d’apprentissage décrites dans <code>vignette("custom-loop")</code>.</p>
<p>Vous devriez maintenant être en mesure de suivre les exemples marqués
avec la catégorie ‘basique’ dans la <a href="https://mlverse.github.io/luz/articles/examples/index.html" class="external-link">galerie
d’exemples</a>.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table des matières"><h2>Sur cette page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Développé par Christophe Regouby.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site créé avec <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
