[{"path":"https://cregouby.github.io/luz.fr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 luz.fr authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://cregouby.github.io/luz.fr/articles/accelerator.html","id":"exemple","dir":"Articles","previous_headings":"","what":"Exemple","title":"L'API des acc√©l√©rateurs","text":"L‚Äôusage est facile √† comprendre sur un exemple de diff√©rence diff du code avec une boucle d‚Äôapprentissage torch brut. Au travers des modifications de code mises en valeur, vous comprenez que vous n‚Äôavez plus besoin de d√©placer manuellement les donn√©es et les mod√®les entre p√©riph√©riques, ce qui rend votre code plus lisible et moins sujet aux erreurs. Vous pouvez trouver des informations suppl√©mentaires en utilisant help(accelerator).","code":"library(torch) + library(luz)  + acc <- accelerator() - device <- \"cpu\"  data <- tensor_dataset(   x = torch_randn(100, 10),   y = torch_rand(100, 1) )  dl <- dataloader(data, batch_size = 10)  model <- nn_linear(10, 1) - model$to(device = device) opt <- optim_adam(model$parameters)  + c(model, opt, dl) %<-% acc$prepare(model, opt, dl)  model$train() coro::loop(for (batch in dl) {    opt$zero_grad()  -  preds <- model(batch$x$to(device = device)) +  preds <- model(batch$x) -  loss <- nnf_mse_loss(preds, batch$y$to(device = device)) +  loss <- nnf_mse_loss(preds, batch$y)    loss$backward()   opt$step() })"},{"path":"https://cregouby.github.io/luz.fr/articles/checkpoints.html","id":"relancer-des-apprentissages-qui-ont-√©chou√©s","dir":"Articles","previous_headings":"","what":"Relancer des apprentissages qui ont √©chou√©s","title":"Sauvegarder des instantann√©s de vos mod√®le","text":"Si vous avez un long processus d‚Äôapprentissage qui peut √©chouer pour n‚Äôimporte quelle raison (ordinateur coup√©, noeud d‚Äôun cluster perdu, etc), il est recommand√© d‚Äôajouter luz_callback_autoresume() √† votre liste de callbacks. luz_callback_autoresume() sauvegardera automatiquement tout l‚Äô√©tat de votre mod√®le √† la fin de chaque √©poque. Si quelque chose se passe mal pendant l‚Äôapprentissage, vous pouvez simplement relancer le m√™me script, sans aucun changement, le dernier instantann√© du mod√®le sera recharg√© et l‚Äôapprentissage reprendra l√† o√π il s‚Äôest arr√™t√©. Par exemple, prennons un jeu de donn√©es d‚Äôentra√Ænement al√©atoire g√©n√©r√© et un mod√®le lin√©aire pour montrer comment fonctionne autoresume. Voici les donn√©es d‚Äôentra√Ænement : Et la d√©finition du mod√®le : Voici comment cr√©er un callbacks qui simule une erreur al√©atoire. Ce callbacks l√®ve juste une erreur d‚Äôex√©cution R √† la 5√®me √©poque d‚Äôapprentissage du mod√®le. Ccommen√ßons par entra√Æner en ajoutant le luz_callback_auto_resume(): Pour relancer l‚Äôapprentissage du mod√®le exactement l√† o√π il s‚Äôest arr√™t√©, vous n‚Äôavez qu‚Äô√† relancer la fonction fit() avec le m√™me mod√®le, les callbacks, etc. : Ainsi, le processus l‚Äôapprentissage du mod√®le continuera exactement l√† o√π il s‚Äôest arr√™t√©. Les registres (de m√©triques et de pertes), l‚Äôoptimiseur et l‚Äô√©tat du mod√®le sont r√©cup√©r√©s √† partir de l‚Äô√©tat pr√©c√©dent pour avoir les r√©sultats complets :","code":"x <- torch_randn(1000, 10) y <- torch_randn(1000, 1) model <- nn_linear %>%   setup(optimizer = optim_sgd, loss = nnf_mse_loss) %>%   set_hparams(in_features = 10, out_features = 1) %>%   set_opt_hparams(lr = 0.01) interrupt <- luz_callback(   \"interrupt\",   failed = FALSE,   on_epoch_end = function() {     if (ctx$epoch == 5 && !self$failed) {       self$failed <- TRUE       stop(\"Error on epoch 5\")     }   } ) autoresume <- luz_callback_auto_resume(path = \"state.pt\") inter <- interrupt()  # Une erreur se produira √† la 5√®me √©poque et le mod√®le sera arr√™t√©. results <- model %>% fit(   list(x, y),   callbacks = list(inter, autoresume),   verbose = FALSE ) #> Error in get(paste0(generic, \".\", class), envir = get_method_env()) :  #>   objet 'type_sum.accel' introuvable #> Error in `FUN()`: #> ! Error while calling callback with class <interrupt/LuzCallback/R6> at #>   on_epoch_end. #> Caused by error in `self[[callback_nm]]()`: #> ! Error on epoch 5 results <- model %>% fit(   list(x, y),   callbacks = list(inter, autoresume),   verbose = FALSE ) plot(results)"},{"path":"https://cregouby.github.io/luz.fr/articles/checkpoints.html","id":"sauvegarde-automatique","dir":"Articles","previous_headings":"","what":"Sauvegarde automatique","title":"Sauvegarder des instantann√©s de vos mod√®le","text":"Si vous d√©sirez avoir un contr√¥le plus fin sur la fa√ßon dont les sauvegardes sont g√©r√©es, vous pouvez utiliser luz_callback_model_checkpoint() pour enregistrer des sauvegardes dans un fichier ou un r√©pertoire sp√©cifi√©. Essayons d‚Äôutiliser le m√™me exemple que dans la section pr√©c√©dente : Nous g√©n√©rerons d‚Äôabord quelques donn√©es. D√©finissons √† nouveau notre mod√®le : Entra√Ænons maintenant le mod√®le en utilisant luz_callback_model_checkpoint(). Vous pouvez maintenant voir que le r√©pertoire checkpoints contient des fichiers avec des sauvegardes de l‚Äô√©tat pour chaque epoch. Par d√©faut, luz_callback_model_checkpoint enregistrera l‚Äô√©tat pour chaque epochs et formattera le nom en y incluant la valeur de la perte. Ce formattage peut √™tre configur√© dans le param√®tre path, voir ?luz_callback_model_checkpoint pour plus de d√©tails. Enfin, vous pouvez charger une sauvegarde sp√©cifique dans le mod√®le entrain√© √† l‚Äôaide de luz_load_checkpoint. Notez que la chargement de la sauvegarde dans un module fitted remplace les poids sur le mod√®le en m√©moire. Vous pouvez ensuite commencer √† faire des pr√©dictions ou √©valuer votre mod√®le avec les poids tout juste charg√©s. Si vous voullez d√©marrer une nouvelle √©poque d‚Äôapprentissage depuis une sauvegarde, vous pouvez utiliser luz_callback_resume_from_checkpoint() . Par d√©faut, il n‚Äôaura enregistr√© que les poids du mod√®le dans le fichier de sauvegarde, mais vous pouvez configurer pour restorer aussi les registres, callbacks et √©tats de l‚Äôoptimiseur. Si le r√©pertoire des sauvegardes existantes est indiqu√©, alors l‚Äôapprentissage reprendra √† partir du dernier fichier de sauvegarde renvoy√© par fs::dir_ls. Voici comment utiliser ce callbacks :","code":"x <- torch_randn(1000, 10) y <- torch_randn(1000, 1) model <- nn_linear %>%   setup(optimizer = optim_sgd, loss = nnf_mse_loss) %>%   set_hparams(in_features = 10, out_features = 1) %>%   set_opt_hparams(lr = 0.01) checkpoint <- luz_callback_model_checkpoint(   path = \"checkpoints/\",    monitor = \"train_loss\" )  results <- model %>% fit(   list(x, y),   callbacks = list(checkpoint),   verbose = FALSE ) fs::dir_ls(\"checkpoints\") #> checkpoints/epoch-01-train_loss-1.237.pt #> checkpoints/epoch-02-train_loss-1.065.pt #> checkpoints/epoch-03-train_loss-1.026.pt #> checkpoints/epoch-04-train_loss-1.004.pt #> checkpoints/epoch-05-train_loss-1.004.pt #> checkpoints/epoch-06-train_loss-1.005.pt #> checkpoints/epoch-07-train_loss-0.999.pt #> checkpoints/epoch-08-train_loss-0.998.pt #> checkpoints/epoch-09-train_loss-1.001.pt #> checkpoints/epoch-10-train_loss-1.002.pt luz_load_checkpoint(results, fs::dir_ls(\"checkpoints\")[1]) resume <- luz_callback_resume_from_checkpoint(path = \"checkpoints/\") results <- model %>% fit(   list(x, y),   callbacks = list(resume),   verbose = FALSE ) plot(results)"},{"path":"https://cregouby.github.io/luz.fr/articles/checkpoints.html","id":"√©tats-des-callbacks-personnalis√©s","dir":"Articles","previous_headings":"Sauvegarde automatique","what":"√âtats des callbacks personnalis√©s","title":"Sauvegarder des instantann√©s de vos mod√®le","text":"Parfois, les rappels ont √©galement besoin de conserver leurs √©tats internes afin de continuer l‚Äôapprentissage exactement √† partir l√† o√π il s‚Äôest arr√™t√©. Dans ce cas, les callbacks peuvent mettre en ≈ìuvre les m√©thodes state_dict() et le load_state_dict() qui sont appel√©es automatiquement lors des sauvegardes et rechargements. Par exemple, imaginez que vous avez cr√©e un callbacks qui suit les gradients des poids du mod√®le √† chaque epoch. Vous voulez utiliser les poids suivis pour analyser plus en profondeur la proc√©dure d‚Äôapprentissage. Ce rappel pourrait √™tre configur√© comme suit: Dans l‚Äôexemple ci-dessus, le champ gradients est un √©tat dans le callbacks. Si l‚Äôapprentissage √©choue pour une raison quelconque, les √©tats seront perdues. Nous pouvons le rendre persistant en utilisant les m√©thodes state_dict() et load_state_dict() comme suit :","code":"cb_weight_grad <- luz_callback(   \"weight_grad\",   gradients = list(),   initialize = function(track_weights) {     self$track_weights   },   on_train_batch_before_step = function() {     gradients[[ctx$epoch]] <- list()     for (w in self$track_weights) {       gradients[[ctx$epoch]][[w]] <- self$model$parameters[[w]]     }   } ) cb_weight_grad <- luz_callback(   \"weight_grad\",   gradients = list(),   initialize = function(track_weights) {     self$track_weights   },   on_train_batch_before_step = function() {     gradients[[ctx$epoch]] <- list()     for (w in self$track_weights) {       gradients[[ctx$epoch]][[w]] <- self$model$parameters[[w]]     }   },   state_dict = function() {     list(gradients = self$gradients)   },   load_state_dict = function(d) {     self$gradients <- d$gradients   } )"},{"path":"https://cregouby.github.io/luz.fr/articles/custom-loop.html","id":"optimiseurs-multiples","dir":"Articles","previous_headings":"","what":"Optimiseurs multiples","title":"Boucles personnalis√©es avec luz","text":"Supposons que notre exp√©rience consiste √† ajuster la premi√®re couche de connexion compl√®te avec un taux d‚Äôapprentissage de 0.1 et la deuxi√®me avec un taux d‚Äôapprentissage de 0.01. Nous allons minimiser la m√™me nn_cross_entropy_loss() pour les deux couches, mais pour la premi√®re, disons que nous voulons ajouter une r√©gularisation L1. Pour y arriver avec luz, va ajouter deux m√©thodes √† notre module net : set_optimizers: qui renvoie une liste d‚Äôoptimiseurs en fonction du contexte ctx. loss: qui calcule une fonction de co√ªt diff√©rente suivant l‚Äôoptimiseur. Voyons le r√©sultat dans le code : Il faut noter que l‚Äôinitialisation des optimiseurs se fera avec le r√©sultat de la m√©thode set_optimizers() qui est une liste. Et donc ici, nous aurons bien deux optimiseurs diff√©rents, appliqu√©s chacuns √† des param√™tres du mod√®le diff√©rents, et avec un taux d‚Äôapprentissage sp√©cifique. La m√©thode loss() en charge le calcul de la fonction de co√ªt, pour faire la retro-propagation des gradients et mettre √† jour les poids du mod√®le. Cette m√©thode loss() acc√®de √† l‚Äôobjet ctx qui contient une variable opt_name d√©crivant l‚Äôoptimiseur en cours d‚Äôutilisation. note que cette fonction sera appell√©e une fois par optimiseur et par √©tape de la boucke d‚Äôentrainement et de la boucle de validation. R√©f√©rez vous √† help(\"ctx\") pour une information compl√®te sur l‚Äôobjet contexte. peut maintenant utiliser setup et fit avec ce module, mais sans pr√©ciser ni les param√™tres d‚Äôoptimiseurs ni de fonction de co√ªt. Maintenant, nous allons re-implementer ce m√™me mod√®le en utilisant une approche l√©g√®rement plus flexible qui consiste √† surcharger l‚Äô√©tape d‚Äôapprentissage et de validation.","code":"net <- nn_module(   \"Net\",   initialize = function() {     self$fc1 <- nn_linear(100, 50)     self$fc1 <- nn_linear(50, 10)   },   forward = function(x) {     x %>%        self$fc1() %>%        nnf_relu() %>%        self$fc2()   },   set_optimizers = function(lr_fc1 = 0.1, lr_fc2 = 0.01) {     list(       opt_fc1 = optim_adam(self$fc1$parameters, lr = lr_fc1),       opt_fc2 = optim_adam(self$fc2$parameters, lr = lr_fc2)     )   },   loss = function(input, target) {     pred <- ctx$model(input)        if (ctx$opt_name == \"opt_fc1\")        # ajout d'une r√©gularisation L1 sur la couche 1       nnf_cross_entropy(pred, target) + torch_norm(self$fc1$weight, p = 1)     else if (ctx$opt_name == \"opt_fc2\")       nnf_cross_entropy(pred, target)   } ) fitted <- net %>%    setup(metrics = list(luz_metric_accuracy)) %>%    fit(train_dl, epochs = 10, valid_data = test_dl)"},{"path":"https://cregouby.github.io/luz.fr/articles/custom-loop.html","id":"√©tape-compl√®tement-flexible","dir":"Articles","previous_headings":"","what":"√âtape compl√®tement flexible","title":"Boucles personnalis√©es avec luz","text":"Au lieu d‚Äôimpl√©menter la m√©thode loss(), nous pouvons impl√©menter la m√©thode step(). Cela permet de modifier en toute flexibilit√© ce qui se passe lors de l‚Äôapprentissage et de la validation pour chaque lot du jeu de donn√©es. C‚Äôest votre code qui est maintenant responsable de mettre √† jour les poids du mod√®le √† chaque appel des optimiseurs par retro-propagation des gradients. Les choses importantes √† noter ici sont : La m√©thode step() est utilis√©e pour l‚Äôapprentissage et la validation. Vous devez √™tre prudent car vous ne devez modifier les poids que pendant la phase d‚Äôapprentissage. Encore une fois, vous pouvez obtenir des informations compl√®tes sur l‚Äôobjet de contexte avec help(\"ctx\"). ctx$optimizers est une liste nomm√©e contenant chaque optimiseur qui √©t√© cr√©√© lorsqu‚Äôappell√© la m√©thode set_optimizers(). Vous devez assurer le suivi les pertes en cours de modification en les enregistrant dans une liste nomm√©e dans ctx$loss. Conform√©ment √† la convention, nous r√©utilisons le nom que l‚Äôoptimiseur auquel elle se r√©f√®re. Il est recommand√© de les d√©connecter avec $detach() avant leur sauvegarde pour r√©duire la consommation de m√©moire. Les rappels qui seraient d√©clench√©s dans la m√©thode step() par d√©faut comme on_train_batch_after_pred, on_train_batch_after_loss, etc., ne seront pas automatiquement appel√©s. Vous pouvez toujours les d√©clencher manuellement en ajoutant ctx$call_callbacks(\"<nom du rappel>)√† l'int√©rieur de votre  √©tape d'apprentissage. √âtudiez le code defit_one_batch()etvalid_one_batch` pour identifier tous les rappels qui ne seront pas d√©clench√©s. Si vous voulez que les m√©triques luz fonctionnent avec votre m√©thode step() personnalis√©e, vous devez assigner ctx$pred aux pr√©dictions du mod√®le car les m√©triques seront toujours appel√©es avec metric$update(ctx$pred, ctx$target).","code":"net <- nn_module(   \"Net\",   initialize = function() {     self$fc1 <- nn_linear(100, 50)     self$fc1 <- nn_linear(50, 10)   },   forward = function(x) {     x %>%        self$fc1() %>%        nnf_relu() %>%        self$fc2()   },   set_optimizers = function(lr_fc1 = 0.1, lr_fc2 = 0.01) {     list(       opt_fc1 = optim_adam(self$fc1$parameters, lr = lr_fc1),       opt_fc2 = optim_adam(self$fc2$parameters, lr = lr_fc2)     )   },   step = function() {     ctx$loss <- list()     for (opt_name in names(ctx$optimizers)) {            ctx$pred <- ctx$model(ctx$input)       opt <- ctx$optimizers[[opt_name]]       loss <- nnf_cross_entropy(pred, target)              if (opt_name == \"opt_fc1\") {         # ajout d'une r√©gularisation L1 sur la couche 1         loss <- nnf_cross_entropy(pred, target) +            torch_norm(self$fc1$weight, p = 1)       }                if (ctx$training) {         opt$zero_grad()         loss$backward()         opt$step()         }              ctx$loss[[opt_name]] <- loss$detach()     }   } )"},{"path":"https://cregouby.github.io/luz.fr/articles/custom-loop.html","id":"√©tapes-suivantes","dir":"Articles","previous_headings":"","what":"√âtapes suivantes","title":"Boucles personnalis√©es avec luz","text":"Dans cet article, vous avez appris √† personnaliser l‚Äô√©tape de formation du boucle d‚Äôapprentissage en utilisant les fonctionnalit√©s en couche de luz. Luz permet √©galement des modifications plus flexibles de la boucle d‚Äôapprentissage d√©crites dans le vignette ‚ÄúAcc√©l√©rateur‚Äù (vignette(\"accelerator\")). Vous devriez maintenant pouvoir suivre les exemples marqu√©s avec les cat√©gories ‚Äòinterm√©diaire‚Äô et ‚Äòavanc√©‚Äô dans la galerie des exemples de luz","code":""},{"path":"https://cregouby.github.io/luz.fr/articles/examples/mnist-autoencoder.html","id":"ensembles-et-chargeurs--","dir":"Articles > Examples","previous_headings":"","what":"Ensembles et chargeurs ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî-","title":"Autoencodeur","text":"dir <- ‚Äú./mnist‚Äù # r√©pertoire de mise en cache","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/articles/examples/mnist-autoencoder.html","id":"category-basic","dir":"Articles > Examples","previous_headings":"Modifiez le dataset MNIST afin que la cible soit identique √† l‚Äôentr√©e.","what":"category: ‚Äòbasic‚Äô","title":"Autoencodeur","text":"","code":"# Packages ---------------------------------------------------------------- library(torch) library(torchvision) library(luz)  # Jeu de donn√©es et chargeurs de donn√©es ----------------------------------------------------  dir <- \"./mnist\" # r√©pertoire de mise en cache  # Modification du jeu de donn√©es MNIST afin que la cible soit identique √† l'entr√©e. mnist_dataset2 <- torch::dataset(   inherit = mnist_dataset,   .getitem = function(i) {     output <- super$.getitem(i)     output$y <- output$x     output   } )  train_ds <- mnist_dataset2(   dir,   download = TRUE,   transform = transform_to_tensor )  test_ds <- mnist_dataset2(   dir,   train = FALSE,   transform = transform_to_tensor )  train_dl <- dataloader(train_ds, batch_size = 128, shuffle = TRUE) test_dl <- dataloader(test_ds, batch_size = 128)  # Construction du r√©seau ---------------------------------------------------  net <- nn_module(   \"Net\",   initialize = function() {     self$encoder <- nn_sequential(       nn_conv2d(1, 6, kernel_size=5),       nn_relu(),       nn_conv2d(6, 16, kernel_size=5),       nn_relu()     )     self$decoder <- nn_sequential(       nn_conv_transpose2d(16, 6, kernel_size = 5),       nn_relu(),       nn_conv_transpose2d(6, 1, kernel_size = 5),       nn_sigmoid()     )   },   forward = function(x) {     x %>%       self$encoder() %>%       self$decoder()   },   predict = function(x) {     self$encoder(x) %>%       torch_flatten(start_dim = 2)   } )  # Entra√Ænement du mod√®le -------------------------------------------------------------------  fitted <- net %>%   setup(     loss = nn_mse_loss(),     optimizer = optim_adam   ) %>%   fit(train_dl, epochs = 1, valid_data = test_dl)  # Inf√©rence ------------------------------------------------------  preds <- predict(fitted, test_dl)  # S√©rialisation ---------------------------------------------------------------  luz_save(fitted, \"mnist-autoencoder.pt\")"},{"path":"https://cregouby.github.io/luz.fr/articles/examples/text-generation.html","id":"donn√©es","dir":"Articles > Examples","previous_headings":"","what":"Donn√©es","title":"Entra√Æner un mod√®le linguistique causal √† partir de z√©ro","text":"La premi√®re √©tape est d‚Äôimpl√©menter un jeu de donn√©es torch qui rassemble des donn√©es et les pr√©-traite pour qu‚Äôelles soient au format appropri√© pour entra√Æner le mod√®le. Cela signifie que nous devons : T√©l√©charger les donn√©es textuelles Entra√Æner un tokeniseur pour ce jeu de donn√©es √ätre en mesure de produire des s√©quences de tokens dans le format attendu par le mod√®le Nous allons utiliser 2 jeux de donn√©es disponibles sur le Hub d‚ÄôHugging Face. Le premier contient tous les codes sources des paquets R disponibles sur CRAN. Le second contient tous les codes R qui sont disponibles dans les dumps GitHub. Les deux jeux de donn√©es sont au format Parquet. Nous allons impl√©menter une fonction qui t√©l√©charge et cache les donn√©es, puis renvoie une seule table au format arrow contenant toutes les donn√©es. Ensuite, nous impl√©mentons une fonction qui entra√Æne un tokeniseur sur notre jeu de donn√©es. Nous pouvons enfin impl√©menter le jeu de donn√©es torch que nous allons utiliser pour entra√Æner le mod√®le. Nous allons utiliser torch::iterable_dataset au lieu de torch::dataset. La principale motivation est que nous ne pouvons pas vraiment savoir le nombre total d‚Äô√©chantillons dans le jeu de donn√©es, donc nous pouvons impl√©menter une m√©thode .getitem() pour obtenir n‚Äôimporte quel √©chantillon arbitraire. Ainsi, nous impl√©mentons la m√©thode .iter qui retourne un nouvel √©chantillon √† chaque appel. Ce jeu de donn√©es est bien trop volumineux pour entra√Æner le mod√®le sur tous les documents dans cet exemple. Il est √©galement difficile de pr√©dire combien de temps cela prendra d‚Äôarriver √† la fin de l‚Äôentra√Ænement. Pour simplifier, nous d√©finissons un jeu de donn√©es it√©rable utilis√© pour ex√©cuter le jeu de donn√©es ci-dessus pendant un nombre fixe d‚Äô√©tapes. Ce n‚Äôest pas n√©cessaire, mais rend l‚Äôutilisation de luz plus agr√©able, car nous pouvons facilement d√©finir combien de tokens nous voulons entra√Æner notre mod√®le. Maintenant, nous pouvons d√©finir le mod√®le que nous allons entra√Æner. Nous utiliserons une version l√©g√®re de GPT2. Nous d√©finissons √©galement une m√©thode generate nous permettant d‚Äô√©chantillonner √† partir du mod√®le donn√© un contexte initial. Pour faciliter l‚Äôinspection de la formation, nous d√©finirons √©galement un callback qui imprime un √©chantillon du mod√®le √† chaque √©poque. Nous pouvons maintenant entra√Æner le mod√®le. Nous d√©finissons un entra√Ænement du mod√®le pour un demi-milliard de tokens pendant un total de 100 √©poques. Ensuite, nous pouvons utiliser le mod√®le pour g√©n√©rer du texte en fonction d‚Äôun prompt avec :","code":"read_dataset <- function(source) {   d <- source |>     hfhub::hub_snapshot(repo_type = \"dataset\", allow_patterns = \"parquet$\") |>     fs::path(\"data/r\") |>     arrow::open_dataset() |>     dplyr::filter(stringr::str_detect(path, \".*\\\\.[rR]$\")) |>     dplyr::select(content) |>     dplyr::mutate(content = arrow::cast(content, arrow::string())) |>     dplyr::filter(!is.na(content)) |>     dplyr::collect() %>%     # le jeu de donn√©es contient des caract√®res utf8 invalides...     # nous devons les supprimer, sinon on obtient une erreur des tokenizers     dplyr::filter(utf8::utf8_valid(content)) }  read_datasets <- function() {   dplyr::bind_rows(     read_dataset(\"dfalbel/cran-packages\"),     read_dataset(\"dfalbel/github-r-repos\")   ) } create_tokenizer <- function(text, vocab_size, special_tokens) {   tok <- tok::tokenizer$new(tok::model_bpe$new())    tok$pre_tokenizer <- tok::pre_tokenizer_byte_level$new(add_prefix_space = FALSE)   tok$decoder <- tok::decoder_byte_level$new()   tok$post_processor <- tok::processor_byte_level$new(trim_offsets = FALSE)    tok$train_from_memory(     text,     tok::trainer_bpe$new(vocab_size = vocab_size, special_tokens = special_tokens)   )   tok }  # code de d√©bogage pour le tokeniseur # data <- read_datasets() # tok <- create_tokenizer(data$content) r_sources_dataset <- torch::iterable_dataset(   \"r_sources_dataset\",   initialize = function(root = \".\", vocab_size = 20000, context_length = 128) {     self$data <- read_datasets()     self$context_length <- context_length     self$index <- sample.int(nrow(self$data))      # nous cr√©ons un tokeniseur que si celui-ci n'existe pas d√©j√†, sinon nous le chargeons simplement     tok_path <- file.path(root, glue::glue(\"tokenizer-{vocab_size}.json\"))     if (!file.exists(tok_path)) {       self$tok <- create_tokenizer(         as.character(self$data$content),         vocab_size,         c(\"<fbegin>\", \"<fend>\")       )       fs::dir_create(root)       self$tok$save(tok_path)     } else {       self$tok <- tok::tokenizer$from_file(tok_path)     }   },   .iter = function() {     i <- 1L     sequence <- c()     function() {       while (length(sequence) < (self$context_length + 1) && i <= nrow(self$data)) {         sequence <<- c(           sequence,           self$tok$encode(paste(\"<fbegin>\", as.character(self$data$content[self$index[i]]), \"<fend>\"))$ids         )         i <- i + 1L       }        if (length(sequence) < (self$context_length + 1)) {         return(coro::exhausted())       }        on.exit({         sequence <<- sequence[-seq_len(self$context_length)]       })       list(         input_ids = sequence[seq_len(self$context_length)] + 1L,         labels = sequence[2:(self$context_length + 1)] + 1L       )     }   } )  # code de d√©bogage pour le jeu de donn√©es # ds <- r_sources_dataset(\"~/Downloads/\") # it <- ds$.iter() # it() # ds$tok$get_vocab_size() fixed_steps_iterable_dataset <- iterable_dataset(   \"fixed_steps_dataset\",   initialize = function(dataset, steps) {     self$dataset <- dataset     self$steps <- steps   },   .iter = function() {     i <- 1L     iter <- NULL     function() {       if (i > self$steps) {         return(coro::exhausted())       }        i <<- i + 1L        if (is.null(iter) || coro::is_exhausted(data <- iter())) {         iter <<- self$dataset$.iter()         data <- iter()       }        data     }   },   .length = function() {     self$steps   } ) net <- nn_module(   initialize = function() {     self$gpt <- minhub::gpt2(       vocab_size = 20000,       pdrop = 0.1     )   },   forward = function(x) {     self$gpt(x)$transpose(2,3)   },   generate = function(x, temperature = 1, iter = 50, top_k = 10) {     # √©chantillonne √† partir du mod√®le given un vecteur de contexte.     for (i in seq_len(iter)) {       logits <- self$forward(x)[,,-1]       logits <- logits/temperature       c(prob, ind) %<-% logits$topk(top_k)       logits <- torch_full_like(logits, -Inf)$scatter_(-1, ind, prob)       logits <- nnf_softmax(logits, dim = -1)       id_next <- torch_multinomial(logits, num_samples = 1)       x <- torch_cat(list(x, id_next), dim = 2)     }     x   } )  # code de d√©bogage pour le mod√®le # ds <- torch::dataloader(r_sources_dataset(\"~/Downloads/\"), batch_size = 32) # batch <- coro::collect(ds, 1)[[1]] # str(batch) # m <- net() # str(m(batch$input_ids)) # √©chantillonne √† partir du mod√®le en utilisant le contexte. generate <- function(model, tok, context, ...) {   local_no_grad() # d√©sactive les gradients pour l'√©chantillonnage   x <- tok$encode(context)$ids + 1L   x <- torch_tensor(x)[NULL,]$to(device = model$device)   content <- as.integer(model$generate(x, ...)$cpu())   tok$decode(content - 1L) }  display_cb <- luz_callback(   initialize = function() {},   on_epoch_end = function() {     local_no_grad()     # sample from the model...     context <- \"# creates a linear model\"     text <- generate(ctx$model, dataset$dataset$tok, context, iter = 100)     cli::cli_rule()     cat(text, \"\\n\")     cli::cli_rule()   } ) n_tokens <- 500e6 batch_size <- 16 epochs <- 100 context_length <- 256L  steps <- n_tokens / context_length / epochs dataset <- fixed_steps_iterable_dataset(   r_sources_dataset(context_length = context_length),   steps = steps )  fitted <- net %>%   setup(     optimizer = optim_adam,     loss = nn_cross_entropy_loss()   ) %>%   set_opt_hparams(lr = 3e-4) |>   fit(     dataset,     epochs = epochs,     dataloader_options = list(batch_size = batch_size),     callbacks = list(       luz_callback_lr_scheduler(         torch::lr_one_cycle,         max_lr = 0.1,         epochs = epochs,         steps_per_epoch = steps/batch_size,         call_on = \"on_batch_end\"       ),       luz_callback_gradient_clip(max_norm = 1),       display_cb()     ),     verbose = TRUE   )  luz::luz_save(fitted, \"model.pt\") fitted <- luz::luz_load(\"model.pt\") tok <- tok::tokenizer$from_file(\"tokenizer-20000.json\") context <- \"#' Cr√©e un mod√®le lin√©aire linear_model <- function(x, y) { \" text <- generate(fitted$model, tok, context, iter = 100) cat(text)"},{"path":"https://cregouby.github.io/luz.fr/articles/get-started.html","id":"entra√Ænement-dun-nn_module","dir":"Articles","previous_headings":"","what":"Entra√Ænement d‚Äôun nn_module","title":"Bien d√©marrer avec luz","text":"Luz tente, autant que possible, de r√©utiliser les structures existantes de torch. Aussi, un r√©seau de neurones est d√©fini avec luz exactement de la m√™me mani√®re qu‚Äôavec torch brut. Par exemple, voici la d√©finition d‚Äôun r√©seau convolutif (CNN feed-forward) qui peut √™tre utilis√©, par exemple, pour classer les images du jeu de donn√©es MNIST: Nous pouvons entra√Æner ce r√©seau en lui appliquant un jeu de donn√©es via le chargeur de donn√©e train_dl et l‚Äô√©valuer grace au torch::dataloaders() nom√© test_dl avec: Voyons en d√©tail ce qui se passe dans lee pr√©c√©dent bloc de code : La fonction setup vous permet de configurer la fonction de co√ªt (objectif) et l‚Äôoptimiseur que vous utiliserez pour entra√Æner votre mod√®le. En option, vous pouvez passer une liste de m√©triques qui sont suivies pendant la proc√©dure d‚Äôapprentissage. Remarque : la fonction de co√ªt peut √™tre n‚Äôimporte quelle fonction prenant en entr√©e input et target et retournant une valeur de tenseur scalaire, et l‚Äôoptimiseur peut √™tre n‚Äôimporte quel optimiseur de torch natif ou personnalis√©, cr√©√© avec la fonction torch::optimizer(). La fonction set_hparams() permet de d√©finir les hyper-param√®tres qui doivent √™tre pass√©es √† la m√©thode initialize() du module. Par exemple, ici nous passons num_classes = 10 qui d√©finit la taille de la derni√®re couche du r√©seau. La fonction set_opt_hparams() vous permet de passer des hyper-param√®tres utilis√©s par la fonction d‚Äôoptimisation. Par exemple, l‚Äôoptimiseur choisi ici optim_adam() peut prendre le param√®tre lr sp√©cifiant le taux d‚Äôapprentissage et nous le sp√©cifions avec lr = 0.003. La m√©thode fit va prendre les sp√©cifications du mod√®le fournies par setup() et ex√©cuter la boucle d‚Äôapprentissage en utilisant les jeux de donn√©e d‚Äôentra√Ænement et de validation sp√©cifi√©s dans des torch::dataloaders() pendant le nombre d‚Äô√©poques. Remarque : nous r√©utilisons les structures de donn√©es de base de torch pour les chargeurs de donn√©e, au lieu de recr√©er notre propre fonctionnalit√© de chargement de donn√©es. L‚Äôobjet retourn√© fitted contient le mod√®le entra√Æn√© ainsi que le registre des m√©triques et de la fonction de pertes produites au cours de l‚Äôapprentissage. Il pourra √™tre utilis√© pour faire de pr√©dictions sur des donn√©es nouvelles, et pour l‚Äô√©valuation du mod√®le entra√Æn√© sur d‚Äôautres jeux de donn√©es. Au moment du lancement de la boucle de calcul, luz utilise l‚Äôacc√©l√©rateur le plus rapide possible; si une carte graphique (GPU) dot√© de CUDA est disponible, elle sera utilis√©e, sinon le calcul sera affect√© √† la CPU. Il d√©place √©galement automatiquement les donn√©es, les optimisateurs et les mod√®les vers le p√©riph√©rique s√©lectionn√© afin d‚Äô√©viter de le programmer manuellement (qui constitue une grande source d‚Äôerreurs en g√©n√©ral). Pour cr√©er des pr√©dictions √† partir du mod√®le entra√Æn√©, vous pouvez utiliser la m√©thode predict:","code":"net <- nn_module(   \"Net\",   initialize = function(num_class) {     self$conv1 <- nn_conv2d(1, 32, 3, 1)     self$conv2 <- nn_conv2d(32, 64, 3, 1)     self$dropout1 <- nn_dropout2d(0.25)     self$dropout2 <- nn_dropout2d(0.5)     self$fc1 <- nn_linear(9216, 128)     self$fc2 <- nn_linear(128, num_class)   },   forward = function(x) {     x <- self$conv1(x)     x <- nnf_relu(x)     x <- self$conv2(x)     x <- nnf_relu(x)     x <- nnf_max_pool2d(x, 2)     x <- self$dropout1(x)     x <- torch_flatten(x, start_dim = 2)     x <- self$fc1(x)     x <- nnf_relu(x)     x <- self$dropout2(x)     x <- self$fc2(x)     x   } ) fitted <- net %>%   setup(     loss = nn_cross_entropy_loss(),     optimizer = optim_adam,     metrics = list(       luz_metric_accuracy     )   ) %>%   set_hparams(num_class = 10) %>%    set_opt_hparams(lr = 0.003) %>%    fit(train_dl, epochs = 10, valid_data = test_dl) predictions <- predict(fitted, test_dl)"},{"path":"https://cregouby.github.io/luz.fr/articles/get-started.html","id":"la-boucle-dentra√Ænement","dir":"Articles","previous_headings":"","what":"La boucle d‚Äôentra√Ænement","title":"Bien d√©marrer avec luz","text":"Maintenant que vous avez une id√©e g√©n√©rale sur la fa√ßon d‚Äôutiliser la fonction fit, il est important d‚Äôavoir un aper√ßu de ce qui se passe √† l‚Äôint√©rieur. Voici le pseudocode de ce que fit ex√©cute. Sans vous montrer l‚Äôint√©gralit√© des op√©rations, cela devrait vous aider √† construire votre intuition:","code":"# -> Initialiser les objets : mod√®le, optimiseurs. # -> S√©lectionner le p√©riph√©rique d'apprentissage (GPU, ...). # -> D√©placer les donn√©es, le mod√®le et les optimiseurs vers le p√©riph√©rique s√©lectionn√©. # -> Lancer l'apprentissage for (epoch in 1:epochs) {   # -> Proc√©dure d'apprentissage   for (batch in train_dl) {     # -> Calculer la m√©thode `forward` du mod√®le.     # -> Calculer la perte.     # -> Mettre √† jour les poids.     # -> Enregistrer les m√©triques et suivre la perte.   }   # -> Proc√©dure de validation   for (batch in valid_dl) {     # -> Calculer la m√©thode `forward` du mod√®le.     # -> Calculer la perte.     # -> Enregistrer les m√©triques et suivre la perte.   } } # -> Fin de l'apprentissage"},{"path":"https://cregouby.github.io/luz.fr/articles/get-started.html","id":"les-m√©triques","dir":"Articles","previous_headings":"","what":"Les m√©triques","title":"Bien d√©marrer avec luz","text":"L‚Äôun des param√™tres les plus importantes des projets d‚Äôapprentissage automatique est le choix de la m√©trique d‚Äô√©valuation. Luz permet de suivre de nombreuses m√©triques diff√©rentes pendant l‚Äôapprentissage avec un effort de codage minime. Pour suivre les m√©triques, il suffit de modifier le param√®tre metrics dans la fonction setup: Luz fournit des impl√©mentations de quelques-unes des m√©triques les plus utilis√©es. Si une m√©trique n‚Äôest pas disponible, vous pouvez toujours la cr√©er √† l‚Äôaide de la fonction luz_metric(). Pour impl√©menter une nouvelle m√©trique luz_metric, il faut d√©finir 3 m√©thodes : initialize : d√©finit l‚Äô√©tat initial de la m√©trique. Cette fonction est appel√©e √† chaque √©poque pour les boucles d‚Äôentra√Ænement et de validation. update : met √† jour l‚Äô√©tat interne de la m√©trique. Cette fonction est appel√©e apr√®s chaque lot d‚Äôentra√Ænement et de validation en comparant les pr√©dictions obtenues par le mod√®le et les valeurs cibles renvoy√©es par le chargeur de donn√©es. compute : utilise l‚Äô√©tat interne pour calculer les valeurs de la m√©trique. Cette fonction est appel√©e toutes les fois o√π il faut mettre √† jour la m√©trique. Par exemple, elle est appel√©e apr√®s chaque lot d‚Äôentra√Ænement pour afficher les informations de progression, mais seulement appel√©e une fois par √©poque pour enregistrer sa valeur lorsqu‚Äôil n‚Äôy pas de barre de progression. Vous pouvez d√©finir un champ optionnel abbrev qui donne √† la m√©trique une abr√©viation utilis√©e lors de l‚Äôaffichage des informations de m√©trique dans la console ou dans les enregistrements. Si aucune valeur n‚Äôest fournie pour abbrev, le nom de classe de la m√©trique est utilis√©. Essayons maintenant de voir l‚Äôimpl√©mentation de luz_metric_accuracy pour mettre en ≈ìuvre une nouvelle m√©trique : Remarque: Il est pr√©f√©rable que la fonction compute retourne des valeurs R natives plut√¥t qu‚Äô√©ventuellement des tenseurs torch. D‚Äôautres parties de luz s‚Äôattendent √† des valeurs R et s‚Äôy attacheront.","code":"fitted <- net %>%   setup(     ...     metrics = list(       luz_metric_accuracy     )   ) %>%   fit(...) luz_metric_accuracy <- luz_metric(   # Une abr√©viation √† afficher dans les barres de progression ou    # lors de l'affichage des informations de progression   abbrev = \"Acc\",    # Initialisation pour la m√©trique. Les m√©triques sont initialis√©es   # √† chaque √©poque, pour les entra√Ænements et pour les validations.   initialize = function() {     self$correct <- 0     self$total <- 0   },   # Mise √† jour √† chaque lot d'entra√Ænement ou de validation.   # La fonction update prend `preds`    # et `target` en param√®tres et met √† jour l'√©tat interne `self`.   update = function(preds, target) {     pred <- torch::torch_argmax(preds, dim = 2)     self$correct <- self$correct + (pred == target)$       to(dtype = torch::torch_float())$       sum()$       item()     self$total <- self$total + pred$numel()   },   # Utilise l'√©tat interne pour demander la valeur de la m√©trique.   compute = function() {     self$correct/self$total   } )"},{"path":"https://cregouby.github.io/luz.fr/articles/get-started.html","id":"√©valuation","dir":"Articles","previous_headings":"","what":"√âvaluation","title":"Bien d√©marrer avec luz","text":"Une fois le mod√®le entra√Æn√©, vous voulez certainement √©valuer sa performance sur un autre jeu de donn√©es. Pour cela, luz fournit la fonction ?evaluate qui prend, en entr√©e, un mod√®le ajust√© et un jeu de donn√©es et calcule les m√©triques attach√©es au mod√®le. La fonction evaluate() retourne un objet de type luz_module_evaluation. Vous pouvez l‚Äôinterroger pour les m√©triques √† l‚Äôaide de la fonction get_metrics() ou simplement imprimer pour voir les r√©sultats. Par exemple :","code":"evaluation <- fitted %>% evaluate(data = valid_dl) metrics <- get_metrics(evaluation) print(evaluation) #> Error in get(paste0(generic, \".\", class), envir = get_method_env()) :  #>   objet 'type_sum.accel' introuvable #> A `luz_module_evaluation` #> -- Results --------------------------------------------------------------------- #> loss: 1.8892 #> mae: 1.0522 #> mse: 1.645 #> rmse: 1.2826"},{"path":"https://cregouby.github.io/luz.fr/articles/get-started.html","id":"personnalisation-avec-les-points-darr√™t-ou-callbacks","dir":"Articles","previous_headings":"","what":"Personnalisation avec les points d‚Äôarr√™t ou callbacks","title":"Bien d√©marrer avec luz","text":"Luz fournit diff√©rentes fa√ßons de personnaliser la boucle d‚Äôapprentissage, en fonction du niveau de contr√¥le dont vous avez besoin pendant qu‚Äôelle s‚Äôex√©cute. La fa√ßon la plus rapide et la plus ¬´ r√©utilisable ¬ª est via les rappels ou callbacks. Ils permettent de cr√©er des modifications d‚Äôapprentissage qui peuvent √™tre utiles dans diverses situations. La boucle d‚Äôapprentissage de luz dispose de nombreux rappels qui peuvent, chacuns, appeler des fonctions R arbitraires. Cette fonctionnalit√© vous permet de personnaliser le processus d‚Äôapprentissage sans entrer dans la logique g√©n√©rale de l‚Äôapprentissage. Luz impl√©mente 3 rappels par d√©faut qui se produisent dans chaque proc√©dure d‚Äôapprentissage : callback train-eval: bascule le mod√®le en mode train() ou eval() selon si la proc√©dure est en cours d‚Äôentra√Ænement ou de validation. callback metrics : √©value les m√©triques au cours du processus d‚Äôentra√Ænement et de validation. callback progress : impl√©mente une barre de progression et affiche des informations sur la progression des lots et des √©poques pendant l‚Äôapprentissage. Vous pouvez √©galement mettre en place des rappels personnalis√©s qui modifient ou agissent sp√©cifiquement pour votre proc√©dure d‚Äôapprentissage, c‚Äôest ce que nous allons montrer dans l‚Äôexemple suivant. Impl√©mentons un callback qui affiche ‚ÄòIt√©ration n‚Äô (o√π n est le num√©ro d‚Äôit√©ration) pour chaque lot du jeu de donn√©es d‚Äôapprentissage et ‚ÄòFini!‚Äô lorsque la fin d‚Äôune √©poque est atteinte. Pour cela, nous utilisons la fonction luz_callback() : luz_callback() prend des fonctions nomm√©es en argument ..., o√π le nom indique le moment auquel le callback doit √™tre appel√©. Par exemple, on_train_batch_end() est appel√© pour chaque fin de lot lors du processus d‚Äôapprentissage, et on_epoch_end() est appel√© √† la fin de chaque √©poque. La valeur retourn√©e par luz_callback() est une fonction qui s‚Äôintancie au moment du callback. Les callbacks peuvent avoir besoin de param√®tres d‚Äôinitialisation, comme par exemple le nom d‚Äôun fichier o√π vous souhaitez enregistrer les r√©sultats. Dans ce cas, vous pouvez passer par une m√©thode initialize lors de la d√©finition du callback, et disposer ces param√®tres dans l‚Äôobjet self. Dans l‚Äôexemple ci-dessus, le callback un param√®tre message qui sera utilis√© pour etre affich√© √† la fin de chaque √©poque. Une fois que le callback est d√©fini, il peut √™tre pass√© √† la fonction fit via le param√®tre callbacks : Les callbacks peuvent √™tre d√©clench√©s √† de nombreuses positions de la boucle d‚Äôapprentissage, y compris en combinaison les uns avec les autres. Voici un aper√ßu des positions possibles pour ins√©rer les callbacks : Chaque √©tape marqu√©e avec on_* est une position dans le processus d‚Äôapprentissage qui est disponible pour d√©clencher les callbacks. L‚Äôautre partie importante des callbacks est l‚Äôobjet contexte ctx . Voir help(\"ctx\") pour plus de d√©tails. Par d√©faut, les callbacks sont d√©clench√©s dans l‚Äôordre dans lequel ils ont √©t√© pass√©s √† fit (ou predict ou evaluate), mais vous pouvez fournir un attribut weight qui contr√¥lera l‚Äôordre croissant dans lequel il sera appel√©. Par exemple, si un callback un weight = 10 et un autre un weight = 1, alors le premier est appel√© apr√®s le second. Les callbacks qui ne sp√©cifient pas d‚Äôattribut de poids sont consid√©r√©s comme ayant un weight = 0. Certains callbacks int√©gr√©s dans luz fournissent d√©j√† une valeur de poids. Par exemple, ?luz_callback_early_stopping une valeur de poids de Inf, puisque en g√©n√©ral souhaite l‚Äôex√©cuter √† la toute fin dans la boucle. Notez que les callbacks peuvent √™tre combin√©s pour effectuer des op√©rations complexes sur le processus d‚Äôapprentissage. La variable ctx est un objet utilis√© dans luz pour partager des informations entre la boucle d‚Äôentra√Ænement et les callbacks, les m√©thodes du mod√®le et les m√©triques. La table suivante d√©crit les informations disponibles par d√©faut dans ctx. D‚Äôautres rappels peuvent potentiellement modifier ces attributs ou en ajouter de nouveaux. Attributs du contexte Les attributs de ctx peuvent √™tre utilis√©s pour produire le comportement souhait√© des callbacks. Vous pouvez trouver de plus amples informations sur l‚Äôobjet de contexte √† l‚Äôaide de help(\"ctx\"). Dans notre exemple, nous utilisons l‚Äôattribut ctx$iter pour afficher le num√©ro d‚Äôit√©ration pour chaque lot d‚Äôapprentissage.","code":"print_callback <- luz_callback(   name = \"print_callback\",   initialize = function(message) {     self$message <- message   },   on_train_batch_end = function() {     cat(\"It√©ration \", ctx$iter, \"\\n\")   },   on_epoch_end = function() {     cat(self$message, \"\\n\")   } ) fitted <- net %>%   setup(...) %>%   fit(..., callbacks = list(     print_callback(message = \"Fini!\")   )) D√©but de boucle d'ajustement    - on_fit_begin   D√©but de l'√©poque      - on_epoch_begin     D√©but de l'apprentissage        - on_train_begin       D√©but de la boucle sur le lot          - on_train_batch_begin           D√©but du lot d'apprentissage par d√©faut             - on_train_batch_after_pred             - on_train_batch_after_loss             - on_train_batch_before_backward             - on_train_batch_before_step             - on_train_batch_after_step           Fin du lot d'apprentissage par d√©faut :          - on_train_batch_end       Fin de la boucle de batch        - on_train_end     Fin de l'apprentissage     D√©but de la validation        - on_valid_begin       D√©but de la boucle sur le lot          - on_valid_batch_begin           D√©but du lot de validation par d√©faut             - on_valid_batch_after_pred             - on_valid_batch_after_loss           Fin du lot de validation par d√©faut          - on_valid_batch_end       Fin de la boucle sur le lot        - on_valid_end     Fin de la validation       - on_epoch_end   Fin de l'√©poque    - on_fit_end Fin de l'ajustement"},{"path":"https://cregouby.github.io/luz.fr/articles/get-started.html","id":"√©tapes-suivantes","dir":"Articles","previous_headings":"","what":"√âtapes suivantes","title":"Bien d√©marrer avec luz","text":"Dans cet article, vous avez appris √† entra√Æner votre premier mod√®le en utilisant luz et les bases de la personnalisation en utilisant √† la fois des m√©triques personnalis√©es et des callbacks. Luz permet √©galement des modifications plus flexibles du processus d‚Äôapprentissage d√©crites dans la vignette(\"custom-loop\"). Vous devriez maintenant √™tre en mesure de suivre les exemples marqu√©s avec la cat√©gorie ‚Äòbasique‚Äô dans la galerie d‚Äôexemples.","code":""},{"path":"https://cregouby.github.io/luz.fr/authors.html","id":null,"dir":"","previous_headings":"","what":"Auteur¬∑rice¬∑s","title":"Auteur¬∑rice¬∑s et Citation","text":"Christophe Regouby. Auteur¬∑rice, mainteneur¬∑se, titulaire des droits d'auteur.","code":""},{"path":"https://cregouby.github.io/luz.fr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Auteur¬∑rice¬∑s et Citation","text":"Regouby C (2025). luz.fr: Une interface de programmation de haut-niveau pour 'torch'. R package version 0.4.0.9000, https://cregouby.github.io/luz.fr/.","code":"@Manual{,   title = {luz.fr: Une interface de programmation de haut-niveau pour 'torch'},   author = {Christophe Regouby},   year = {2025},   note = {R package version 0.4.0.9000},   url = {https://cregouby.github.io/luz.fr/}, }"},{"path":"https://cregouby.github.io/luz.fr/index.html","id":"luzfr-","dir":"","previous_headings":"","what":"Une interface de programmation de haut-niveau pour torch","title":"Une interface de programmation de haut-niveau pour torch","text":"Le paquet d‚Äôinternationalisation de {luz} en fran√ßais (fr_FR)","code":""},{"path":"https://cregouby.github.io/luz.fr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Une interface de programmation de haut-niveau pour torch","text":"Vous pouvez installer la version de development de {luz.fr} depuis GitHub via:","code":"# install.packages(\"devtools\") devtools::install_github(\"cregouby/luz.fr\")"},{"path":"https://cregouby.github.io/luz.fr/index.html","id":"exemple","dir":"","previous_headings":"","what":"Exemple","title":"Une interface de programmation de haut-niveau pour torch","text":"Voici comment utiliser {luz} avec l‚Äôaide en fran√ßais :","code":"# configure la session en langue fran√ßaise Sys.setenv(LANGUAGE = \"fr\")  # charge la librairie d'aide de luz en traduction fran√ßaise et {luz} library(luz.fr) library(luz)  # consulte l'aide normalement ??lr_finder"},{"path":"https://cregouby.github.io/luz.fr/reference/accelerator.html","id":null,"dir":"Reference","previous_headings":"","what":"Cr√©e un acc√©l√©rateur  üåê  Create an accelerator ‚Äî accelerator","title":"Cr√©e un acc√©l√©rateur  üåê  Create an accelerator ‚Äî accelerator","text":"Cr√©e un acc√©l√©rateur","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/accelerator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Cr√©e un acc√©l√©rateur  üåê  Create an accelerator ‚Äî accelerator","text":"","code":"accelerator(   device_placement = TRUE,   cpu = FALSE,   cuda_index = torch::cuda_current_device() )"},{"path":"https://cregouby.github.io/luz.fr/reference/accelerator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cr√©e un acc√©l√©rateur  üåê  Create an accelerator ‚Äî accelerator","text":"device_placement (bool√©en) si l'objet accelerator doit g√©rer le placement sur les cartes acc√©l√©ratrices. Par d√©faut : TRUE cpu (bool√©en) le processus d'apprentissage doit-il s'ex√©cuter sur le processeur central ? cuda_index (entier) index de la carte CUDA √† utiliser si plusieurs GPUs sont disponibles. Par d√©faut : le r√©sultat de torch::cuda_current_device()","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/as_dataloader.html","id":null,"dir":"Reference","previous_headings":"","what":"Cr√©e un chargeur de donn√©es √† partir de son entr√©e.  üåê  Creates a dataloader from its input ‚Äî as_dataloader","title":"Cr√©e un chargeur de donn√©es √† partir de son entr√©e.  üåê  Creates a dataloader from its input ‚Äî as_dataloader","text":"as_dataloader est utilis√© en interne par luz pour convertir les entr√©es data et valid_data pass√©s √† fit.luz_module_generator() en un torch::dataloader","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/as_dataloader.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Cr√©e un chargeur de donn√©es √† partir de son entr√©e.  üåê  Creates a dataloader from its input ‚Äî as_dataloader","text":"","code":"as_dataloader(x, ...)  # M√©thode S3 pour la classe dataset as_dataloader(x, ..., batch_size = 32)  # M√©thode S3 pour la classe iterable_dataset as_dataloader(x, ..., batch_size = 32)  # M√©thode S3 pour la classe list as_dataloader(x, ...)  # M√©thode S3 pour la classe dataloader as_dataloader(x, ...)  # M√©thode S3 pour la classe matrix as_dataloader(x, ...)  # M√©thode S3 pour la classe numeric as_dataloader(x, ...)  # M√©thode S3 pour la classe array as_dataloader(x, ...)  # M√©thode S3 pour la classe torch_tensor as_dataloader(x, ...)"},{"path":"https://cregouby.github.io/luz.fr/reference/as_dataloader.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cr√©e un chargeur de donn√©es √† partir de son entr√©e.  üåê  Creates a dataloader from its input ‚Äî as_dataloader","text":"x l'objet d'entr√©e. ... Pass√© √† torch::dataloader(). batch_size (entier, facultatif) : nombre d'observations par lot (par d√©faut: 32).","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/as_dataloader.html","id":"d-tails","dir":"Reference","previous_headings":"","what":"D√©tails","title":"Cr√©e un chargeur de donn√©es √† partir de son entr√©e.  üåê  Creates a dataloader from its input ‚Äî as_dataloader","text":"Les m√©thodes as_dataloader permettent de choisir finement les param√®tres par d√©faut pour la taille du lot, les workers parall√®les, etc. Elle permet aux utilisateurs de tester rapidement fit.luz_module_generator() sans avoir besoin de cr√©er un torch::dataset et un torch::dataloader pour l'exp√©rimentation.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/as_dataloader.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Cr√©e un chargeur de donn√©es √† partir de son entr√©e.  üåê  Creates a dataloader from its input ‚Äî as_dataloader","text":"as_dataloader(dataset) : Convertit un torch::dataset() en un torch::dataloader(). as_dataloader(iterable_dataset) : Convertit un torch::iterable_dataset() en un torch::dataloader() as_dataloader(list) : Convertit une liste de tenseurs ou d'arrays ayant tous la m√™me taille dans leur premi√®re dimension en un torch::dataloader() as_dataloader(dataloader) : Retourne le m√™me chargeur de donn√©es as_dataloader(matrix) : Convertit la matrice en un chargeur de donn√©es as_dataloader(numeric) : Convertit le vecteur num√©rique en un chargeur de donn√©es as_dataloader(array) : Convertit l'array en un chargeur de donn√©es as_dataloader(torch_tensor) : Convertit le tenseur en un chargeur de donn√©es","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/as_dataloader.html","id":"overriding","dir":"Reference","previous_headings":"","what":"Overriding","title":"Cr√©e un chargeur de donn√©es √† partir de son entr√©e.  üåê  Creates a dataloader from its input ‚Äî as_dataloader","text":"Vous pouvez impl√©menter votre propre m√©thode S3 de as_dataloader si vous voulez que votre structure de donn√©es soit automatiquement prise en charge par luz's fit.luz_module_generator(). La m√©thode doit satisfaire les conditions suivantes : La m√©thode doit retourner un torch::dataloader(). L'unique argument requis est `x`. Vous avez des param√®tres avec de bonnes valeurs par d√©faut pour tous les autres arguments. Il faut √©viter l'impl√©mentation de m√©thodes as_dataloader pour les classes S3 courantes comme data.frames. Si n√©cessaire, il est pr√©f√©rable d'affecter une classe S3 sp√©cifique aux inputs et d'impl√©menter as_dataloader pour cette classe.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":null,"dir":"Reference","previous_headings":"","what":"Objet de type contexte  üåê  Context object ‚Äî context","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"Objet de type context stockant des informations sur le contexte d'entra√Ænement du mod√®le. Voir √©galement ctx.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"buffers une liste de buffers que les callbacks peuvent utiliser pour une √©criture temporaire d'information dans le  ctx.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"active-bindings","dir":"Reference","previous_headings":"","what":"Active bindings","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"records stores information values logged self$log. device allows querying current accelerator device callbacks list callbacks called. iter current iteration batch current batch data. list input data targets. input shortcut ctx$batch[[1]] target shortcut ctx$batch[[2]] min_epochs minimum number epochs model run . max_epochs maximum number epochs model run. hparams list hyperparameters used initialize ctx$model. opt_hparams list hyperparameters used initialize ctx$optimizers. train_data dataloader used training model valid_data dataloader using model validation accelerator accelerator() used move data, model etc correct device. optimizers named list optimizers used model training. verbose bool wether process verbose mode . handlers List error handlers can used. See rlang::try_fetch() info. epoch_handlers List error handlers can used. See rlang::try_fetch() info. training bool indicating model training validation mode. model model trained. pred Last predicted values. opt Current optimizer. opt_name Current optimizer name. data Current dataloader use. loss_fn Loss function used train model loss Last computed loss values. Detached graph. loss_grad Last computed loss value, detached, can additional tranformation. epoch Current epoch. metrics List metrics tracked process. step_opt Defines step called optimizer. must function taking optimizer argument.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"context$new() context$log() context$log_metric() context$get_log() context$get_metrics() context$get_metric() context$get_formatted_metrics() context$get_metrics_df() context$set_verbose() context$clean() context$call_callbacks() context$state_dict() context$unsafe_set_records() context$clone()","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"Initializes context object minimal necessary information.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"","code":"context$new(verbose, accelerator, callbacks, training)"},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"verbose Whether context verbose mode . accelerator luz accelerator() configures device placement others. callbacks list callbacks used model. See luz_callback(). training boolean indicates context training mode .","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"method-log-","dir":"Reference","previous_headings":"","what":"Method log()","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"Allows logging arbitrary information ctx.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"","code":"context$log(what, set, value, index = NULL, append = TRUE)"},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"(string) logging. set (string) Usually 'train' 'valid' indicating set want lot . can arbitrary info. value value log value Arbitrary value log. index Index value logged. NULL value added end list, otherwise index used. append TRUE value corresponding index already exists, value appended current value. FALSE value overwritten favor new value.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"method-log-metric-","dir":"Reference","previous_headings":"","what":"Method log_metric()","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"Log metric gen name value. Metric values indexed epoch.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"","code":"context$log_metric(name, value)"},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"name name metric value value log value Arbitrary value log.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"method-get-log-","dir":"Reference","previous_headings":"","what":"Method get_log()","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"Get specific value log.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"","code":"context$get_log(what, set, index = NULL)"},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"(string) logging. set (string) Usually 'train' 'valid' indicating set want lot . can arbitrary info. index Index value logged. NULL value added end list, otherwise index used.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"method-get-metrics-","dir":"Reference","previous_headings":"","what":"Method get_metrics()","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"Get metric given epoch set.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"","code":"context$get_metrics(set, epoch = NULL)"},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"set (string) Usually 'train' 'valid' indicating set want lot . can arbitrary info. epoch epoch want extract metrics .","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"method-get-metric-","dir":"Reference","previous_headings":"","what":"Method get_metric()","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"Get value metric given name, epoch set.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"","code":"context$get_metric(name, set, epoch = NULL)"},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"name name metric set (string) Usually 'train' 'valid' indicating set want lot . can arbitrary info. epoch epoch want extract metrics .","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"method-get-formatted-metrics-","dir":"Reference","previous_headings":"","what":"Method get_formatted_metrics()","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"Get formatted metrics values","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"","code":"context$get_formatted_metrics(set, epoch = NULL)"},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"set (string) Usually 'train' 'valid' indicating set want lot . can arbitrary info. epoch epoch want extract metrics .","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"method-get-metrics-df-","dir":"Reference","previous_headings":"","what":"Method get_metrics_df()","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"Get data.frame containing metrics.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"","code":"context$get_metrics_df()"},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"method-set-verbose-","dir":"Reference","previous_headings":"","what":"Method set_verbose()","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"Allows setting verbose attribute.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"","code":"context$set_verbose(verbose = NULL)"},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"verbose boolean. TRUE verbose mode used. FALSE non verbose. NULL use result interactive().","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"method-clean-","dir":"Reference","previous_headings":"","what":"Method clean()","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"Removes unnecessary information context object.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"","code":"context$clean()"},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"method-call-callbacks-","dir":"Reference","previous_headings":"","what":"Method call_callbacks()","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"Call selected callbacks. name callback types call, eg 'on_epoch_begin'.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"","code":"context$call_callbacks(name)"},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"name name metric","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"method-state-dict-","dir":"Reference","previous_headings":"","what":"Method state_dict()","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"Returns list containing minimal information context. Used create returned values.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"","code":"context$state_dict()"},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"method-unsafe-set-records-","dir":"Reference","previous_headings":"","what":"Method unsafe_set_records()","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"sure know ?","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"usage-12","dir":"Reference","previous_headings":"","what":"Usage","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"","code":"context$unsafe_set_records(records)"},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"arguments-9","dir":"Reference","previous_headings":"","what":"Arguments","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"records New set records set.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"objects class cloneable method.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"usage-13","dir":"Reference","previous_headings":"","what":"Usage","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"","code":"context$clone(deep = FALSE)"},{"path":"https://cregouby.github.io/luz.fr/reference/context.html","id":"arguments-10","dir":"Reference","previous_headings":"","what":"Arguments","title":"Objet de type contexte  üåê  Context object ‚Äî context","text":"deep Whether make deep clone.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/ctx.html","id":null,"dir":"Reference","previous_headings":"","what":"Objet Context  üåê  Context object ‚Äî ctx","title":"Objet Context  üåê  Context object ‚Äî ctx","text":"Les objets context sont utilis√©s par luz pour l'√©change d'information entre m√©thodes, m√©triques et callbaks.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/ctx.html","id":"d-tails","dir":"Reference","previous_headings":"","what":"D√©tails","title":"Objet Context  üåê  Context object ‚Äî ctx","text":"L'objet ctx est utilis√© par luz pour partager des m√©thodes entre la boucle d'entra√Ænement, les callbacks, les m√©thodes du mod√®les et les m√©triques. La table ci-dessous liste les informations disponibles dans ctx par d√©faut. Les autres callbacks peuvent potentiellement modifier ces attributs et en ajouter d'autres. Attributs du contexte","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/evaluate.html","id":null,"dir":"Reference","previous_headings":"","what":"√âvalue un mod√®le entra√Æn√© sur un jeu de donn√©es  üåê  Evaluates a fitted model on a dataset ‚Äî evaluate","title":"√âvalue un mod√®le entra√Æn√© sur un jeu de donn√©es  üåê  Evaluates a fitted model on a dataset ‚Äî evaluate","text":"√âvalue un mod√®le entra√Æn√© sur un jeu de donn√©es","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/evaluate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"√âvalue un mod√®le entra√Æn√© sur un jeu de donn√©es  üåê  Evaluates a fitted model on a dataset ‚Äî evaluate","text":"","code":"evaluate(   object,   data,   ...,   metrics = NULL,   callbacks = list(),   accelerator = NULL,   verbose = NULL,   dataloader_options = NULL )"},{"path":"https://cregouby.github.io/luz.fr/reference/evaluate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"√âvalue un mod√®le entra√Æn√© sur un jeu de donn√©es  üåê  Evaluates a fitted model on a dataset ‚Äî evaluate","text":"object Un mod√®le entra√Æn√©. data (dataloader, dataset ou liste) Un chargeur de donn√©es cr√©√© avec torch::dataloader() sur lequel √©valuer le mod√®le, ou un dataset cr√©√© avec torch::dataset() ou une liste. Les chargeur de donn√©ess et les datasets doivent retourner une liste avec au plus 2 items. Le premier item sera utilis√© comme pr√©dicteurs pour le module et le second sera utilis√© comme variable √† pr√©dire pour la fonction de perte. ... Inutilis√© metrics Une liste de m√©triques de luz √† appliquer pendant l'√©valuation. Si NULL (par d√©faut) alors les m√™mes m√©triques que les m√©triques d'entra√Ænement sont √©valu√©es. callbacks (facultatif) Une liste de callbacks d√©finis avec luz_callback() qui seront appel√©s pendant la proc√©dure d'entra√Ænement. Les callbacks luz_callback_metrics(), luz_callback_progress() et luz_callback_train_valid() sont toujours ajout√©s par d√©faut. accelerator Un acc√©l√©rateur accelerator() √† utiliser pour le calcul des objets tels que les modules nn, les optimiseurs et les batch de donn√©es. verbose (bool√©en) La proc√©dure d'entra√Ænement doit-elle produire des messages dans la console. Par d√©faut, elle produira des messages s'il y une interface graphique (c'est-√†-dire si interactive() est vrai), sinon elle ne produira pas de messages. dataloader_options Des options utilis√©es lors de la cr√©ation d'un chargeur de donn√©es. Voir torch::dataloader(). Par d√©fautshuffle=TRUE pour les donn√©es d'entra√Ænement et batch_size=32. Il y aura une erreur si non NULL et si data est d√©ja un chargeur de donn√©es.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/evaluate.html","id":"d-tails","dir":"Reference","previous_headings":"","what":"D√©tails","title":"√âvalue un mod√®le entra√Æn√© sur un jeu de donn√©es  üåê  Evaluates a fitted model on a dataset ‚Äî evaluate","text":"Une fois que vous avez entra√Æn√© un mod√®le, vous pouvez √©valuer sa performance sur un autre jeu de donn√©es. Pour cela, luz fournit la fonction evaluate. Cette derni√®re prend en argument un mod√®le entra√Æn√© et un jeu de donn√©es, puis calcule les m√©triques li√©es au mod√®le. La fonction evaluate retourne un objet luz_module_evaluation, que vous pouvez consulter gr√¢ce √† la fonction get_metrics() ou simplement print pour voir les r√©sultats. Par exemple:","code":"evaluation <- fitted  metrics <- get_metrics(evaluation) print(evaluation) ## A `luz_module_evaluation` ## -- Results --------------------------------------------------------------------- ## loss: 1.5146 ## mae: 1.0251 ## mse: 1.5159 ## rmse: 1.2312"},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/fit.luz_module_generator.html","id":null,"dir":"Reference","previous_headings":"","what":"Entra√Æne un nn_module  üåê  Fit a nn_module ‚Äî fit.luz_module_generator","title":"Entra√Æne un nn_module  üåê  Fit a nn_module ‚Äî fit.luz_module_generator","text":"Entra√Æne un nn_module","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/fit.luz_module_generator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Entra√Æne un nn_module  üåê  Fit a nn_module ‚Äî fit.luz_module_generator","text":"","code":"# M√©thode S3 pour la classe luz_module_generator fit(   object,   data,   epochs = 10,   callbacks = NULL,   valid_data = NULL,   accelerator = NULL,   verbose = NULL,   ...,   dataloader_options = NULL )"},{"path":"https://cregouby.github.io/luz.fr/reference/fit.luz_module_generator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Entra√Æne un nn_module  üåê  Fit a nn_module ‚Äî fit.luz_module_generator","text":"object Un nn_module qui est pass√© par la commande setup(). data (dataloader, dataset ou list) Un chargeur de donn√©e cr√©√© avec torch::dataloader() utilis√© pour l'entra√Ænement du mod√®le, ou un jeu de donn√©es cr√©√© avec torch::dataset() ou une liste. Les chargeurs de donn√©e et les jeux de donn√©es doivent renvoyer une liste contenant au plus 2 √©l√©ments. Le premier √©l√©ment sera utilis√© comme entr√©e pour le module et le second comme variable √† pr√©dire pour la fonction de perte. epochs (entier) Le nombre maximal d'√©poques d'entra√Ænement du mod√®le. Si une valeur unique est fournie, elle sera prise comme max_epochs et min_epochs sera √† 0. Si un vecteur de deux nombres est fourni, la premi√®re valeur sera min_epochs et la seconde valeur sera max_epochs. Le nombre minimum et maximum d'√©poques sont inclus dans l'objet context sous forme de ctx$min_epochs et ctx$max_epochs, respectivement. callbacks (optionnel) Une liste de callbacks d√©finis avec luz_callback() qui seront appel√©s pendant la proc√©dure d'entra√Ænement. Les callbacks luz_callback_metrics(), luz_callback_progress() et luz_callback_train_valid() sont toujours ajout√©s par d√©faut. valid_data (dataloader, dataset, liste ou r√©el; optionnel) Un chargeur de donn√©e cr√©√© avec torch::dataloader() ou un jeu de donn√©es cr√©√© avec torch::dataset() qui sera utilis√© pendant la proc√©dure de validation. Ils doivent retourner une liste contenant (input, target). Si data est un torch::dataset() ou une liste, vous pouvez √©galement fournir une valeur num√©rique entre 0 et 1 - et dans ce cas, une √©chantillonnage al√©atoire avec taille correspondante √† celle proportionnelle √† partir de data sera utilis√©e pour la validation. accelerator (accelerator, optional) Un objet accelerator() optionnel utilis√© pour configurer le device cible du calcul pour des composants tels que les modules nn, les optimiseurs et batches de donn√©es. verbose (bool√©en, optionnel) La proc√©dure d'entra√Ænement doit-elle produire ses messages vers la console pendant l'entra√Ænement. Par d√©faut, elle produira des message si interactive() est TRUE, sinon elle ne publiera pas vers la console. ... Inutilis√© dataloader_options Options utilis√©es lors de la cr√©ation d'un chargeur de donn√©e. Voir torch::dataloader(). shuffle=TRUE par d√©faut pour les donn√©es d'entra√Ænement et batch_size=32 par d√©faut. Il y aura erreur si ce n'est pas NULL quand data est d√©j√† un chargeur de donn√©e.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/fit.luz_module_generator.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Entra√Æne un nn_module  üåê  Fit a nn_module ‚Äî fit.luz_module_generator","text":"Un objet entra√Æn√© qui peut √™tre enregistr√© avec luz_save(), affich√© avec print() et visualis√© avec plot().","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/get_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Extrait les m√©triques de l'objet  üåê  Get metrics from the object ‚Äî get_metrics","title":"Extrait les m√©triques de l'objet  üåê  Get metrics from the object ‚Äî get_metrics","text":"Extrait les m√©triques de l'objet","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/get_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Extrait les m√©triques de l'objet  üåê  Get metrics from the object ‚Äî get_metrics","text":"","code":"get_metrics(object, ...)  # M√©thode S3 pour la classe luz_module_fitted get_metrics(object, ...)"},{"path":"https://cregouby.github.io/luz.fr/reference/get_metrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extrait les m√©triques de l'objet  üåê  Get metrics from the object ‚Äî get_metrics","text":"object L'objet d'o√π extraire les m√©triques ... Inutilis√©","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/get_metrics.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Extrait les m√©triques de l'objet  üåê  Get metrics from the object ‚Äî get_metrics","text":"Un data.frame contenant les valeurs des m√©triques","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/get_metrics.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Extrait les m√©triques de l'objet  üåê  Get metrics from the object ‚Äî get_metrics","text":"get_metrics(luz_module_fitted): Extrait les m√©triques d'un mod√®le luz entra√Æn√©.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/lr_finder.html","id":null,"dir":"Reference","previous_headings":"","what":"Recherche du taux d'apprentissage  üåê  Learning Rate Finder ‚Äî lr_finder","title":"Recherche du taux d'apprentissage  üåê  Learning Rate Finder ‚Äî lr_finder","text":"Recherche du taux d'apprentissage","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/lr_finder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Recherche du taux d'apprentissage  üåê  Learning Rate Finder ‚Äî lr_finder","text":"","code":"lr_finder(   object,   data,   steps = 100,   start_lr = 1e-07,   end_lr = 0.1,   log_spaced_intervals = TRUE,   ...,   verbose = NULL )"},{"path":"https://cregouby.github.io/luz.fr/reference/lr_finder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recherche du taux d'apprentissage  üåê  Learning Rate Finder ‚Äî lr_finder","text":"object Un module nn qui √©t√© configur√© par setup(). data (dataloader) Un chargeur de donn√©e cr√©√© avec torch::dataloader(), utilis√© pour le recherche de taux d'apprentissage. steps (entier) Le nombre d'it√©rations pour la recherche de taux d'apprentissage. D√©faut : 100. start_lr (r√©el) La limite basse du taux d'apprentissage. end_lr (r√©el) La limite haute du taux d'apprentissage. log_spaced_intervals (bool√©en) Doit-d√©couper logarithmiquement l'intervalle entre start_lr et end_lr (Si FALSE : intervalles uniformes). D√©faut : TRUE ... Autres arguments pass√©s √† fit. verbose Doit-afficher un barre de progression pendant la recherche.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/lr_finder.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Recherche du taux d'apprentissage  üåê  Learning Rate Finder ‚Äî lr_finder","text":"Un dataframe de deux colonnes : taux d'apprentissage et valeur de la fonction de perte","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback.html","id":null,"dir":"Reference","previous_headings":"","what":"Cr√©er un nouveau callback  üåê  Create a new callback ‚Äî luz_callback","title":"Cr√©er un nouveau callback  üåê  Create a new callback ‚Äî luz_callback","text":"Cr√©e un nouveau callback","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Cr√©er un nouveau callback  üåê  Create a new callback ‚Äî luz_callback","text":"","code":"luz_callback(   name = NULL,   ...,   private = NULL,   active = NULL,   parent_env = parent.frame(),   inherit = NULL )"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cr√©er un nouveau callback  üåê  Create a new callback ‚Äî luz_callback","text":"name nom du callback ... M√©thodes publiques du callback. Le nom des m√©thodes est utilis√© pour savoir comment elles doivent √™tre appel√©es. Voir la section d√©tails. private Une liste optionnelle de m√©thodes priv√©es, qui peuvent √™tre des fonctions et non-des fonctions. active Une liste optionnelle de fonctions d'active binding. parent_env Un environnement √† utiliser comme parent pour les objets nouvellement cr√©√©s. inherit Un objet R6ClassGenerator duquel h√©riter; autrement dit, une super-classe. Cela est captur√© comme une expression non-√©valu√©e qui sera √©valu√©e dans parent_env chaque fois qu'un objet est instanci√©.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Cr√©er un nouveau callback  üåê  Create a new callback ‚Äî luz_callback","text":"Un callback luz_callback que l'peut passer √† fit.luz_module_generator().","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback.html","id":"d-tails","dir":"Reference","previous_headings":"","what":"D√©tails","title":"Cr√©er un nouveau callback  üåê  Create a new callback ‚Äî luz_callback","text":"Let‚Äôs implement callback prints ‚ÄòIteration n‚Äô (n iteration number) every batch training set ‚ÄòDone‚Äô epoch finished. task use luz_callback function:   luz_callback() takes named functions ... arguments, name indicates moment callback called. instance on_train_batch_end() called every batch end training procedure, on_epoch_end() called end every epoch. returned value luz_callback() function initializes instance callback. Callbacks can initialization parameters, like name file want log results. case, can pass initialize method creating callback definition, save parameters self object. example, callback message parameter printed end epoch. callback defined can passed fit function via callbacks parameter:   Callbacks can called many different positions training loop, including combinations . ‚Äôs overview possible callback breakpoints:   Every step market on_* point training procedure available callbacks called. important part callbacks ctx (context) object. See help(\"ctx\") details. default, callbacks called order passed fit (predict evaluate), can provide weight attribute control order called. example, one callback weight = 10 another weight = 1, first one called second one. Callbacks don‚Äôt specify weight attribute considered weight = 0. built-callbacks luz already provide weight value. example, ?luz_callback_early_stopping weight Inf, since general want run last thing loop.","code":"print_callback <- luz_callback(   name = \"print_callback\",   initialize = function(message) {     self$message <- message   },   on_train_batch_end = function() {     cat(\"Iteration \", ctx$iter, \"\\n\")   },   on_epoch_end = function() {     cat(self$message, \"\\n\")   } ) fitted <- net    setup(...)    fit(..., callbacks = list(     print_callback(message = \"Done!\")   )) Start Fit    - on_fit_begin   Start Epoch Loop      - on_epoch_begin     Start Train        - on_train_begin       Start Batch Loop          - on_train_batch_begin           Start Default Training Step             - on_train_batch_after_pred             - on_train_batch_after_loss             - on_train_batch_before_backward             - on_train_batch_before_step             - on_train_batch_after_step           End Default Training Step:          - on_train_batch_end       End Batch Loop        - on_train_end     End Train     Start Valid        - on_valid_begin       Start Batch Loop          - on_valid_batch_begin           Start Default Validation Step             - on_valid_batch_after_pred             - on_valid_batch_after_loss           End Default Validation Step          - on_valid_batch_end       End Batch Loop        - on_valid_end     End Valid       - on_epoch_end   End Epoch Loop    - on_fit_end End Fit"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback.html","id":"prediction-callbacks","dir":"Reference","previous_headings":"","what":"Prediction callbacks","title":"Cr√©er un nouveau callback  üåê  Create a new callback ‚Äî luz_callback","text":"can also use callbacks using predict(). case supported callback methods detailed .","code":"Start predict  - on_predict_begin  Start prediction loop   - on_predict_batch_begin   - on_predict_batch_end  End prediction loop  - on_predict_end End predict"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback.html","id":"evaluate-callbacks","dir":"Reference","previous_headings":"","what":"Evaluate callbacks","title":"Cr√©er un nouveau callback  üåê  Create a new callback ‚Äî luz_callback","text":"Les fonctions de callback peuvent √©galement √™tre utilis√©es avec evaluate(), dans ce cas, les callbacks utilis√©s sont √©quivalents √† ceux de la boucle de validation lors de l'utilisation de fit():","code":"D√©but de Validation  - on_valid_begin  D√©but de Boucle de Validation du Lot   - on_valid_batch_begin   D√©but de l'√©tape de Validation par d√©faut    - on_valid_batch_after_pred    - on_valid_batch_after_loss   Fin de l'√©tape de Validation par d√©faut   - on_valid_batch_end  Fin du Lot  - on_valid_end Fin de Validation"},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Exemples","title":"Cr√©er un nouveau callback  üåê  Create a new callback ‚Äî luz_callback","text":"","code":"print_callback <- luz_callback(  name = \"print_callback\",  on_train_batch_end = function() {    cat(\"Iteration \", ctx$iter, \"\\n\")  },  on_epoch_end = function() {    cat(\"Done!\\n\")  } ) #> Error in luz_callback(name = \"print_callback\", on_train_batch_end = function() {    cat(\"Iteration \", ctx$iter, \"\\n\")}, on_epoch_end = function() {    cat(\"Done!\\n\")}): impossible de trouver la fonction \"luz_callback\""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_auto_resume.html","id":null,"dir":"Reference","previous_headings":"","what":"Callback de reprise de l'entra√Ænement du mod√®le.  üåê  Resume training callback ‚Äî luz_callback_auto_resume","title":"Callback de reprise de l'entra√Ænement du mod√®le.  üåê  Resume training callback ‚Äî luz_callback_auto_resume","text":"Ce callback vous permet de reprendre l'entra√Ænement du mod√®le.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_auto_resume.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Callback de reprise de l'entra√Ænement du mod√®le.  üåê  Resume training callback ‚Äî luz_callback_auto_resume","text":"","code":"luz_callback_auto_resume(path = \"./state.pt\")"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_auto_resume.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Callback de reprise de l'entra√Ænement du mod√®le.  üåê  Resume training callback ‚Äî luz_callback_auto_resume","text":"path Chemin o√π sauvegarder les fichiers d'instantan√© du mod√®le.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_auto_resume.html","id":"d-tails","dir":"Reference","previous_headings":"","what":"D√©tails","title":"Callback de reprise de l'entra√Ænement du mod√®le.  üåê  Resume training callback ‚Äî luz_callback_auto_resume","text":"Quand l'utilise, les poids du mod√®le et l'√©tat de l'optimiseur sont s√©rialis√©s √† la fin de chaque √©poque. Si quelque chose √©choue pendant l'entra√Ænement, r√©ex√©cuter le m√™me script reprendra l'entra√Ænement du mod√®le √† l'√©poque qui suit la derni√®re √©poque s√©rialis√©e.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_auto_resume.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Callback de reprise de l'entra√Ænement du mod√®le.  üåê  Resume training callback ‚Äî luz_callback_auto_resume","text":"En g√©n√©ral, vous voudrez ajouter ce callback en dernier dans la liste de callbacks, car ainsi, l'√©tat s√©rialis√© est susceptible de contenir toutes les modifications possibles apport√©es par d'autres callbacks √† 'on_epoch_end'. Le weight par d√©faut de ce callback est Inf. Voir la vignette sur les instantan√©s pour plus de d√©tails.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_auto_resume.html","id":"customizing-serialization","dir":"Reference","previous_headings":"","what":"Customizing serialization","title":"Callback de reprise de l'entra√Ænement du mod√®le.  üåê  Resume training callback ‚Äî luz_callback_auto_resume","text":"Par d√©faut, le mod√®le, l'√©tat de l'optimiseur et l'√©tat des callbacks sont s√©rialis√©s. Les callbacks peuvent √™tre utilis√©s pour personnaliser la s√©rialisation en impl√©mentant les m√©thodes state_dict() et load_state_dict(). Si ces m√©thodes sont impl√©ment√©es, alors state_dict() est appel√©e √† la fin de chaque √©poque et load_state_dict() est appel√©e lorsque le mod√®le reprend.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_csv_logger.html","id":null,"dir":"Reference","previous_headings":"","what":"Callback pour journaliser les m√©triques en CSV  üåê  CSV logger callback ‚Äî luz_callback_csv_logger","title":"Callback pour journaliser les m√©triques en CSV  üåê  CSV logger callback ‚Äî luz_callback_csv_logger","text":"Logs metrics obtained training fiel disk. file 1 line epoch/validation.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_csv_logger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Callback pour journaliser les m√©triques en CSV  üåê  CSV logger callback ‚Äî luz_callback_csv_logger","text":"","code":"luz_callback_csv_logger(path)"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_csv_logger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Callback pour journaliser les m√©triques en CSV  üåê  CSV logger callback ‚Äî luz_callback_csv_logger","text":"path chemin de fichier sur le disque.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_early_stopping.html","id":null,"dir":"Reference","previous_headings":"","what":"Callback d'arr√™t pr√©coce  üåê  Early stopping callback ‚Äî luz_callback_early_stopping","title":"Callback d'arr√™t pr√©coce  üåê  Early stopping callback ‚Äî luz_callback_early_stopping","text":"Stoppe l'entra√Ænement lorsque le m√©trique suivie cesse de s'am√©liorer","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_early_stopping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Callback d'arr√™t pr√©coce  üåê  Early stopping callback ‚Äî luz_callback_early_stopping","text":"","code":"luz_callback_early_stopping(   monitor = \"valid_loss\",   min_delta = 0,   patience = 0,   mode = \"min\",   baseline = NULL )"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_early_stopping.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Callback d'arr√™t pr√©coce  üåê  Early stopping callback ‚Äî luz_callback_early_stopping","text":"monitor Une cha√Æne au format <set>_<metric> o√π <set> peut √™tre 'train' ou 'valid' et <metric> est l'abr√©viation d'une m√©trique qui est suivie pendant l'entra√Ænement. Le nom de la m√©trique est insensible √† la casse. min_delta Am√©lioration minimale pour r√©initialiser le compteur de patience. patience Nombre d'√©poques sans am√©lioration avant de stopper l'entra√Ænement. mode Sp√©cifie la direction consid√©r√©e comme une am√©lioration. Par d√©faut, 'min' est utilis√©. Cela peut √©galement √™tre 'max' (lorque cherche √† maximiser la m√©trique) et 'zero' (plus proche de z√©ro est mieux). baseline Une valeur initiale qui sera utilis√©e comme la meilleure valeur vue. L'entra√Ænement s'arr√™tera si aucune valeur meilleure que la valeur de r√©f√©rence n'est trouv√©e dans les premi√®res patience √©poques.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_early_stopping.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Callback d'arr√™t pr√©coce  üåê  Early stopping callback ‚Äî luz_callback_early_stopping","text":"Un luz_callback qui d√©clenche l'arr√™t pr√©coce de l'entra√Ænement.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_early_stopping.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Callback d'arr√™t pr√©coce  üåê  Early stopping callback ‚Äî luz_callback_early_stopping","text":"Ce callback ajoute un callback on_early_stopping qui peut √™tre utilis√© pour appeler d'autres callbacks d√®s que l'entra√Ænement s'arr√™te . Si verbose=TRUE dans fit.luz_module_generator(), alors un message est imprim√© lors de l'arr√™t pr√©coce de l'entra√Ænement.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_early_stopping.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Exemples","title":"Callback d'arr√™t pr√©coce  üåê  Early stopping callback ‚Äî luz_callback_early_stopping","text":"","code":"cb <- luz_callback_early_stopping() #> Error in luz_callback_early_stopping(): impossible de trouver la fonction \"luz_callback_early_stopping\""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_gradient_clip.html","id":null,"dir":"Reference","previous_headings":"","what":"Callback d'√©cr√™tage du gradient  üåê  Gradient clipping callback ‚Äî luz_callback_gradient_clip","title":"Callback d'√©cr√™tage du gradient  üåê  Gradient clipping callback ‚Äî luz_callback_gradient_clip","text":"En ajoutant le callback GradientClip, la norme norm_type (par d√©faut:2) des gradients est √©cr√™t√©e √† la valeur max_norm (par d√©faut: 1) utilisant torch::nn_utils_clip_grad_norm_(), ce qui peut √©viter la divergence de la fonction de co√ªt.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_gradient_clip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Callback d'√©cr√™tage du gradient  üåê  Gradient clipping callback ‚Äî luz_callback_gradient_clip","text":"","code":"luz_callback_gradient_clip(max_norm = 1, norm_type = 2)"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_gradient_clip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Callback d'√©cr√™tage du gradient  üåê  Gradient clipping callback ‚Äî luz_callback_gradient_clip","text":"max_norm (entier ou r√©el) : norme maximale des gradients norm_type (entier ou r√©el) : type de la norme p utilis√©e. Peut √™tre Inf pour la norme infinie.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_gradient_clip.html","id":"r-f-rences","dir":"Reference","previous_headings":"","what":"R√©f√©rences","title":"Callback d'√©cr√™tage du gradient  üåê  Gradient clipping callback ‚Äî luz_callback_gradient_clip","text":"Voir FastAI documentation pour le callback de GradientClip.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_interrupt.html","id":null,"dir":"Reference","previous_headings":"","what":"Callback d'interruption  üåê  Interrupt callback ‚Äî luz_callback_interrupt","title":"Callback d'interruption  üåê  Interrupt callback ‚Äî luz_callback_interrupt","text":"Ajoute un gestionnaire qui permet d'interrompre la boucle d'apprentissage en utilisant ctrl + C. Enregistre √©galement un point d'interruption on_interrupt afin que les utilisateurs puissent enregistrer d'autres callbacks qui seront ex√©cut√©s lors de l'interruption de la boucle d'apprentissage.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_interrupt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Callback d'interruption  üåê  Interrupt callback ‚Äî luz_callback_interrupt","text":"","code":"luz_callback_interrupt()"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_interrupt.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Callback d'interruption  üåê  Interrupt callback ‚Äî luz_callback_interrupt","text":"Un luz_callback","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_interrupt.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Callback d'interruption  üåê  Interrupt callback ‚Äî luz_callback_interrupt","text":"Vous n'avez g√©n√©ralement pas √† utiliser ces callbacks par vous-m√™me, car ils sont toujours inclus par d√©faut dans fit.luz_module_generator().","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_interrupt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Exemples","title":"Callback d'interruption  üåê  Interrupt callback ‚Äî luz_callback_interrupt","text":"","code":"interrupt_callback <- luz_callback_interrupt() #> Error in luz_callback_interrupt(): impossible de trouver la fonction \"luz_callback_interrupt\""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_keep_best_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Conserver le meilleur mod√®le  üåê  Keep the best model ‚Äî luz_callback_keep_best_model","title":"Conserver le meilleur mod√®le  üåê  Keep the best model ‚Äî luz_callback_keep_best_model","text":"√Ä chaque √©poque, si il y am√©lioration dans la m√©trique surveill√©e, sauvegarde les poids du mod√®le dans un fichier temporaire. Lorsque l'entra√Ænement est termin√©, recharge les poids du meilleur mod√®le.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_keep_best_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Conserver le meilleur mod√®le  üåê  Keep the best model ‚Äî luz_callback_keep_best_model","text":"","code":"luz_callback_keep_best_model(   monitor = \"valid_loss\",   mode = \"min\",   min_delta = 0 )"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_keep_best_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conserver le meilleur mod√®le  üåê  Keep the best model ‚Äî luz_callback_keep_best_model","text":"monitor Une cha√Æne au format <set>_<metric> o√π <set> peut √™tre 'train' ou 'valid' et <metric> est l'abr√©viation d'une m√©trique qui est suivie pendant l'entra√Ænement. Le nom de la m√©trique est insensible √† la casse. mode Sp√©cifie la direction consid√©r√©e comme une am√©lioration. Par d√©faut, 'min' est utilis√©. Cela peut √©galement √™tre 'max' (lorque cherche √† maximiser la m√©trique) et 'zero' (plus proche de z√©ro est mieux). min_delta Am√©lioration minimale pour r√©initialiser le compteur de patience.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_keep_best_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Exemples","title":"Conserver le meilleur mod√®le  üåê  Keep the best model ‚Äî luz_callback_keep_best_model","text":"","code":"cb <- luz_callback_keep_best_model() #> Error in luz_callback_keep_best_model(): impossible de trouver la fonction \"luz_callback_keep_best_model\""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_lr_scheduler.html","id":null,"dir":"Reference","previous_headings":"","what":"Callback de modification du taux d'apprentissage  üåê  Learning rate scheduler callback ‚Äî luz_callback_lr_scheduler","title":"Callback de modification du taux d'apprentissage  üåê  Learning rate scheduler callback ‚Äî luz_callback_lr_scheduler","text":"Initialisation et ex√©cution des torch::lr_scheduler()s.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_lr_scheduler.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Callback de modification du taux d'apprentissage  üåê  Learning rate scheduler callback ‚Äî luz_callback_lr_scheduler","text":"","code":"luz_callback_lr_scheduler(   lr_scheduler,   ...,   call_on = \"on_epoch_end\",   opt_name = NULL )"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_lr_scheduler.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Callback de modification du taux d'apprentissage  üåê  Learning rate scheduler callback ‚Äî luz_callback_lr_scheduler","text":"lr_scheduler Un torch::lr_scheduler() qui sera initialis√© avec l'optimiseur et les param√®tres ... . ... Arguments suppl√©mentaires pass√©s avec l'optimiseur √† lr_scheduler. call_on Le point d'arr√™t du callback auquel scheduler$step() est appel√©. Par d√©faut c'est 'on_epoch_end'. Voir luz_callback() pour plus d'informations. opt_name Nom de l'optimiseur qui sera affect√© par ce callback. Doit correspondre au nom donn√© dans set_optimizers. Si votre module un seul optimiseur, opt_name n'est pas utilis√©.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_lr_scheduler.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Callback de modification du taux d'apprentissage  üåê  Learning rate scheduler callback ‚Äî luz_callback_lr_scheduler","text":"Un g√©n√©rateur luz_callback().","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_lr_scheduler.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Exemples","title":"Callback de modification du taux d'apprentissage  üåê  Learning rate scheduler callback ‚Äî luz_callback_lr_scheduler","text":"","code":"if (torch::torch_is_installed()) { cb <- luz_callback_lr_scheduler(torch::lr_step, step_size = 30) } #> Error in luz_callback_lr_scheduler(torch::lr_step, step_size = 30): impossible de trouver la fonction \"luz_callback_lr_scheduler\""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Callback sur les m√©triques  üåê  Metrics callback ‚Äî luz_callback_metrics","title":"Callback sur les m√©triques  üåê  Metrics callback ‚Äî luz_callback_metrics","text":"Suit les m√©triques pass√©es √† setup() pendant l'entra√Ænement et la validation.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Callback sur les m√©triques  üåê  Metrics callback ‚Äî luz_callback_metrics","text":"","code":"luz_callback_metrics()"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_metrics.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Callback sur les m√©triques  üåê  Metrics callback ‚Äî luz_callback_metrics","text":"Un luz_callback","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_metrics.html","id":"d-tails","dir":"Reference","previous_headings":"","what":"D√©tails","title":"Callback sur les m√©triques  üåê  Metrics callback ‚Äî luz_callback_metrics","text":"Ce callback s'occupe de 2 attributs de  ctx: ctx$metrics: stocke les objets de m√©triques courants qui sont r√©initialis√©s une fois par √©poque, et qui seront plus tard mis √† jour pas update() et calcul√©s pas compute() √† chaque lot. Vous aurez rarement besoin de travailler avec ces m√©triques. ctx$records$metrics: Stocke les m√©triques pour entra√Ænement et validation pour chaque √©poque. La structure est tr√®s similaire √† ctx$losses.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_metrics.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Callback sur les m√©triques  üåê  Metrics callback ‚Äî luz_callback_metrics","text":"En g√©n√©ral, vous n'avez pas besoin d'utiliser explicitement le callback de m√©triques car il est utilis√© par d√©faut dans fit.luz_module_generator().","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_mixed_precision.html","id":null,"dir":"Reference","previous_headings":"","what":"Callback de gestion automatique de la pr√©cision mixte  üåê  Automatic Mixed Precision callback ‚Äî luz_callback_mixed_precision","title":"Callback de gestion automatique de la pr√©cision mixte  üåê  Automatic Mixed Precision callback ‚Äî luz_callback_mixed_precision","text":"Ce callback activera l'entra√Ænement du mod√®le torch::local_autocast() pendant la phase forward() et pendant le calcul de la fonction de co√ªt. Il d√©sactivera ensuite l'autocast et normalisera la fonction de co√ªt avant la phase backward() et opt$step(). Pour en savoir plus, voir  ici.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_mixed_precision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Callback de gestion automatique de la pr√©cision mixte  üåê  Automatic Mixed Precision callback ‚Äî luz_callback_mixed_precision","text":"","code":"luz_callback_mixed_precision(...)"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_mixed_precision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Callback de gestion automatique de la pr√©cision mixte  üåê  Automatic Mixed Precision callback ‚Äî luz_callback_mixed_precision","text":"... Pass√© √† torch::cuda_amp_grad_scaler().","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_mixed_precision.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Callback de gestion automatique de la pr√©cision mixte  üåê  Automatic Mixed Precision callback ‚Äî luz_callback_mixed_precision","text":"Un callback de type luz_callback","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_mixup.html","id":null,"dir":"Reference","previous_headings":"","what":"Callback de mixup  üåê  Mixup callback ‚Äî luz_callback_mixup","title":"Callback de mixup  üåê  Mixup callback ‚Äî luz_callback_mixup","text":"Mise en ≈ìuvre de 'mixup: Beyond Empirical Risk Minimization'. Actuellement test√© uniquement pour les donn√©es cat√©gorielles, o√π les variables √† pr√©dire sont encod√©es comme des entiers, et pas encod√©es en binaire un-contre-tous. Ce callback doit √™tre utilis√© simultan√©ment avec `nn_mixup_loss()`.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_mixup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Callback de mixup  üåê  Mixup callback ‚Äî luz_callback_mixup","text":"","code":"luz_callback_mixup(alpha = 0.4, ..., run_valid = FALSE, auto_loss = FALSE)"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_mixup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Callback de mixup  üåê  Mixup callback ‚Äî luz_callback_mixup","text":"alpha param√®tre de la distribution b√©ta utilis√©e pour √©chantillonner les coefficients de m√©lange ... actuellement non utilis√©. Juste pour forcer des arguments nomm√©s. run_valid Doit-il s'ex√©cuter aussi pendant la validation ? auto_loss Doit-modifier automatiquement la fonction de co√ªt ? Cela cr√©era une fonction de perte mixup bas√©e sur la fonction de co√ªt. Si TRUE, assurez-vous que votre fonction de co√ªt n'applique pas de r√©duction. Si run_valid=FALSE, la fonction de co√ªt sera r√©duite √† sa moyenne pendant la validation.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_mixup.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Callback de mixup  üåê  Mixup callback ‚Äî luz_callback_mixup","text":"Un callback `luz_callback`","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_mixup.html","id":"d-tails","dir":"Reference","previous_headings":"","what":"D√©tails","title":"Callback de mixup  üåê  Mixup callback ‚Äî luz_callback_mixup","text":"Dans l'ensemble, nous suivons l'impl√©mentation de fastai d√©crite ici. √Ä savoir, Nous travaillons avec un seul chargeur de donn√©e, en m√©langeant deux observations al√©atoirement √† partir du m√™me lot. Nous combinons lin√©airement les pertes calcul√©es pour les deux cibles : loss(output, new_target) = weight * loss(output, target1) + (1-weight) * loss(output, target2) Nous tirons des coefficients de m√©lange diff√©rents pour chaque paire. Nous rempla√ßons weight par weight = max(weight, 1-weight) pour √©viter les r√©p√©titions. (torch::torch_is_installed()) mixup_callback <- luz_callback_mixup() nn_mixup_loss(), nnf_mixup()Autres luz_callbacks: luz_callback_auto_resume(), luz_callback_csv_logger(), luz_callback_early_stopping(), luz_callback_interrupt(), luz_callback_keep_best_model(), luz_callback_lr_scheduler(), luz_callback_metrics(), luz_callback_mixed_precision(), luz_callback_model_checkpoint(), luz_callback_profile(), luz_callback_progress(), luz_callback_resume_from_checkpoint(), luz_callback_train_valid(), luz_callback()  luz_callbacks","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_model_checkpoint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Sauvegarde un instantann√© du mod√®le  üåê  Checkpoints model weights ‚Äî luz_callback_model_checkpoint","text":"","code":"luz_callback_model_checkpoint(   path,   monitor = \"valid_loss\",   save_best_only = FALSE,   mode = \"min\",   min_delta = 0 )"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_model_checkpoint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sauvegarde un instantann√© du mod√®le  üåê  Checkpoints model weights ‚Äî luz_callback_model_checkpoint","text":"path Chemin pour sauvegarder le mod√®le sur disque dur. Le chemin est interpol√© avec glue, donc vous pouvez utiliser tout attribut dans le ctx en utilisant '{ctx$epoch}'. Par exemple, les valeurs epoch et monitor sont d√©j√† pr√©sentes dans l'environnement. Si le chemin sp√©cifi√© est un r√©pertoire (se termine par / ou }), alors les mod√®les sont sauvegard√©s avec le nom fourni par \\verb{epoch-{epoch:02d}-{self$monitor}-{monitor:.3f}.pt}. Voir les exemples. Vous pouvez utiliser \\code{\\link[=sprintf]{sprintf()}} pour formater rapidement les valeurs, par exemple:\\code{'{epoch:02d}'}. monitorUne cha√Æne au format <set>_<metric> o√π <set> peut √™tre 'train' ou 'valid' et <metric> est l'abr√©viation de toute m√©trique suivie pendant l'entra√Ænement. Le nom de la m√©trique est insensible √† la casse. save_best_onlySi TRUE, les mod√®les ne sont sauvegard√©s que si ils am√©liorent un mod√®le pr√©c√©demment enregistr√©. modeSp√©cifie la direction consid√©r√©e comme une am√©lioration. Par d√©faut, 'min' est utilis√©. Cela peut √©galement √™tre 'max' (lorque cherche √† maximiser la m√©trique) et 'zero' (plus proche de z√©ro est mieux). min_deltaDiff√©rence minimale √† consid√©rer comme une am√©lioration. Seulement utilis√©e lorsque save_best_only=TRUE. Sauvegarde l'instantann√© du mod√®le selon la m√©trique sp√©cifi√©e et le comportement. mode et min_delta ne sont utilis√©s que lorsque save_best_only=TRUE. save_best_only √©crasera les mod√®les enregistr√©s si le param√®tre path ne diff√©rencie pas les noms des mod√®les par epochs.Voir la vignette sur les instantan√©s pour plus de d√©tails. luz_callback_model_checkpoint(path= \"path//dir\") luz_callback_model_checkpoint(path= \"path//dir/epoch-epoch:02d/model.pt\") luz_callback_model_checkpoint(path= \"path//dir/epoch-epoch:02d/model-monitor:.2f.pt\") Autres callbacks luz: luz_callback_auto_resume(), luz_callback_csv_logger(), luz_callback_early_stopping(), luz_callback_interrupt(), luz_callback_keep_best_model(), luz_callback_lr_scheduler(), luz_callback_metrics(), luz_callback_mixup(), luz_callback_model_checkpoint(), luz_callback_profile(), luz_callback_progress(), luz_callback_resume_from_checkpoint(), luz_callback_train_valid(), luz_callback()  luz_callbacks","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_profile.html","id":null,"dir":"Reference","previous_headings":"","what":"Callback de profilage  üåê  Profile callback ‚Äî luz_callback_profile","title":"Callback de profilage  üåê  Profile callback ‚Äî luz_callback_profile","text":"Calcule les temps pour les op√©rations de haut niveau dans les boucles d'apprentissage.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_profile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Callback de profilage  üåê  Profile callback ‚Äî luz_callback_profile","text":"","code":"luz_callback_profile()"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_profile.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Callback de profilage  üåê  Profile callback ‚Äî luz_callback_profile","text":"Un callback de type luz_callback","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_profile.html","id":"d-tails","dir":"Reference","previous_headings":"","what":"D√©tails","title":"Callback de profilage  üåê  Profile callback ‚Äî luz_callback_profile","text":"Les valeurs sont enregistr√©s dans ctx$records$profile. Les temps sont en secondes. Les donn√©es sont stock√©es avec la structure suivante : fit temps de l'ensemble de la precedure fit. epoch temps par √©poque.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_profile.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Callback de profilage  üåê  Profile callback ‚Äî luz_callback_profile","text":"En g√©n√©ral, vous n'avez pas besoin d'utiliser ce callback par vous-m√™me car il est toujours inclus par d√©faut dans fit.luz_module_generator().","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_profile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Exemples","title":"Callback de profilage  üåê  Profile callback ‚Äî luz_callback_profile","text":"","code":"profile_callback <- luz_callback_profile() #> Error in luz_callback_profile(): impossible de trouver la fonction \"luz_callback_profile\""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_progress.html","id":null,"dir":"Reference","previous_headings":"","what":"Callback de progression  üåê  Progress callback ‚Äî luz_callback_progress","title":"Callback de progression  üåê  Progress callback ‚Äî luz_callback_progress","text":"Affiche une bare de progression pendant l'entra√Ænement.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_progress.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Callback de progression  üåê  Progress callback ‚Äî luz_callback_progress","text":"","code":"luz_callback_progress()"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_progress.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Callback de progression  üåê  Progress callback ‚Äî luz_callback_progress","text":"Un callback de type luz_callback","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_progress.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Callback de progression  üåê  Progress callback ‚Äî luz_callback_progress","text":"En g√©n√©ral, vous n'avez pas besoin d'utiliser ce callback par vous-m√™me car il est toujours inclus par d√©faut en fit.luz_module_generator(). L'affichage peut √™tre d√©sactiv√© en passant verbose=FALSE √† fit.luz_module_generator().","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_resume_from_checkpoint.html","id":null,"dir":"Reference","previous_headings":"","what":"Permettre la reprise de l'entra√Ænement du mod√®le √† partir d'un instantan√© sp√©cifique.  üåê  Allow resume model training from a specific checkpoint ‚Äî luz_callback_resume_from_checkpoint","title":"Permettre la reprise de l'entra√Ænement du mod√®le √† partir d'un instantan√© sp√©cifique.  üåê  Allow resume model training from a specific checkpoint ‚Äî luz_callback_resume_from_checkpoint","text":"Permet de reprendre l'entra√Ænement d'un mod√®le √† partir d'un instantann√©.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_resume_from_checkpoint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Permettre la reprise de l'entra√Ænement du mod√®le √† partir d'un instantan√© sp√©cifique.  üåê  Allow resume model training from a specific checkpoint ‚Äî luz_callback_resume_from_checkpoint","text":"","code":"luz_callback_resume_from_checkpoint(   path,   ...,   restore_model_state = TRUE,   restore_records = FALSE,   restore_optimizer_state = FALSE,   restore_callbacks_state = FALSE )"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_resume_from_checkpoint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Permettre la reprise de l'entra√Ænement du mod√®le √† partir d'un instantan√© sp√©cifique.  üåê  Allow resume model training from a specific checkpoint ‚Äî luz_callback_resume_from_checkpoint","text":"path Chemin du fichier de poids interm√©diaires. ... inutilis√© restore_model_state Wether restore model state callback. restore_records Doit-restaurer les enregistrements √† partir de l'instantan√©. restore_optimizer_state Doit-restaurer l'√©tat de l'optimiseur √† partir de l'instantan√©. restore_callbacks_state Doit-restaurer l'√©tat des callbacks √† partir de l'instantan√©.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_resume_from_checkpoint.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Permettre la reprise de l'entra√Ænement du mod√®le √† partir d'un instantan√© sp√©cifique.  üåê  Allow resume model training from a specific checkpoint ‚Äî luz_callback_resume_from_checkpoint","text":"Voir la vignette sur les instantan√©s pour plus de d√©tails.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_tfevents.html","id":null,"dir":"Reference","previous_headings":"","what":"callback tfevent  üåê  tfevents callback ‚Äî luz_callback_tfevents","title":"callback tfevent  üåê  tfevents callback ‚Äî luz_callback_tfevents","text":"Enregistre des m√©triques et d'autres informations du mod√®le sous forme de fichier tfevents. Quand tensorboard est install√©, il peut √™tre utilis√© pour visualiser les r√©sultats.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_tfevents.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"callback tfevent  üåê  tfevents callback ‚Äî luz_callback_tfevents","text":"","code":"luz_callback_tfevents(logdir = \"logs\", histograms = FALSE, ...)"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_tfevents.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"callback tfevent  üåê  tfevents callback ‚Äî luz_callback_tfevents","text":"logdir Un r√©pertoire o√π sera √©crit le journal. histograms Un bool√©en sp√©cifiant si les histogrammes des poids du mod√®le doivent √™tre enregistr√©s. Peut aussi √™tre un vecteur de cha√Æne de caract√®res sp√©cifiant les noms des param√®tres √† enregistrer (noms identiques √† names(model$parameters)). ... Inutilis√©","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_tfevents.html","id":"d-tails","dir":"Reference","previous_headings":"","what":"D√©tails","title":"callback tfevent  üåê  tfevents callback ‚Äî luz_callback_tfevents","text":"","code":"tensorboard --logdir=logs"},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_train_valid.html","id":null,"dir":"Reference","previous_headings":"","what":"callback train-eval  üåê  Train-eval callback ‚Äî luz_callback_train_valid","title":"callback train-eval  üåê  Train-eval callback ‚Äî luz_callback_train_valid","text":"Bascule les param√®tres importants entre les modes d'apprentissage et de validation.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_train_valid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"callback train-eval  üåê  Train-eval callback ‚Äî luz_callback_train_valid","text":"","code":"luz_callback_train_valid()"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_train_valid.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"callback train-eval  üåê  Train-eval callback ‚Äî luz_callback_train_valid","text":"Un luz_callback","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_train_valid.html","id":"d-tails","dir":"Reference","previous_headings":"","what":"D√©tails","title":"callback train-eval  üåê  Train-eval callback ‚Äî luz_callback_train_valid","text":"Il s'occupe des trois attributs suivants de l'objet ctx : ctx$model: G√®re l'appel √† ctx$model$train() et ctx$model$eval(), lorsque c'est appropri√©. ctx$training: Fixe ce fanion √† TRUE lors de l'apprentissage et √† FALSE lors de la validation. ctx$loss: R√©initialise l'attribut loss √† list() lorsque l'apprentissage ou la validation est termin√©.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_callback_train_valid.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"callback train-eval  üåê  Train-eval callback ‚Äî luz_callback_train_valid","text":"general need explicitly use metrics callback used default fit.luz_module_generator().","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_load.html","id":null,"dir":"Reference","previous_headings":"","what":"Charge un mod√®le entrain√© depuis le disque  üåê  Load trained model ‚Äî luz_load","title":"Charge un mod√®le entrain√© depuis le disque  üåê  Load trained model ‚Äî luz_load","text":"Charge un mod√®le entra√Æn√©. Voir la documentation dans luz_save().","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_load.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Charge un mod√®le entrain√© depuis le disque  üåê  Load trained model ‚Äî luz_load","text":"","code":"luz_load(path)"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_load.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Charge un mod√®le entrain√© depuis le disque  üåê  Load trained model ‚Äî luz_load","text":"path path file system save object.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_load_checkpoint.html","id":null,"dir":"Reference","previous_headings":"","what":"Charge un instantann√©  üåê  Loads a checkpoint ‚Äî luz_load_checkpoint","title":"Charge un instantann√©  üåê  Loads a checkpoint ‚Äî luz_load_checkpoint","text":"Fonctionne avec les instantan√©s cr√©√©s avec luz_callback_model_checkpoint().","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_load_checkpoint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Charge un instantann√©  üåê  Loads a checkpoint ‚Äî luz_load_checkpoint","text":"","code":"luz_load_checkpoint(obj, path, ...)"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_load_checkpoint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Charge un instantann√©  üåê  Loads a checkpoint ‚Äî luz_load_checkpoint","text":"obj Object want laod checkpoint. path Chemin de l'instantan√© sur le disque. ... inutilis√©.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_load_model_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Charge des poids sauvegard√©s sur disque, dans un mod√®le.  üåê  Loads model weights into a fitted object. ‚Äî luz_load_model_weights","title":"Charge des poids sauvegard√©s sur disque, dans un mod√®le.  üåê  Loads model weights into a fitted object. ‚Äî luz_load_model_weights","text":"Peut √™tre utile quand vous avez sauvegard√© des instantan√©s de mod√®le pendant l'entra√Ænement, et que vous voulez restaurer le meilleur instantan√© √† la fin.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_load_model_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Charge des poids sauvegard√©s sur disque, dans un mod√®le.  üåê  Loads model weights into a fitted object. ‚Äî luz_load_model_weights","text":"","code":"luz_load_model_weights(obj, path, ...)  luz_save_model_weights(obj, path)"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_load_model_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Charge des poids sauvegard√©s sur disque, dans un mod√®le.  üåê  Loads model weights into a fitted object. ‚Äî luz_load_model_weights","text":"obj Objet luz sur lequel copier les nouveaux poids. path Chemin du fichier de poids sauvegard√© sur le disque. ... Autres arguments pass√©s √† torch_load().","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_load_model_weights.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Charge des poids sauvegard√©s sur disque, dans un mod√®le.  üåê  Loads model weights into a fitted object. ‚Äî luz_load_model_weights","text":"Retourne NULL de mani√®re invisible.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_load_model_weights.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Charge des poids sauvegard√©s sur disque, dans un mod√®le.  üåê  Loads model weights into a fitted object. ‚Äî luz_load_model_weights","text":"luz_save_model_weights op√®re directement sur l'objet, c-√†-d qu'il modifie le mod√®le pour lui affecter les nouveaux poids.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric.html","id":null,"dir":"Reference","previous_headings":"","what":"Cr√©e une nouvelle m√©trique luz  üåê  Creates a new luz metric ‚Äî luz_metric","title":"Cr√©e une nouvelle m√©trique luz  üåê  Creates a new luz metric ‚Äî luz_metric","text":"Cr√©e une nouvelle m√©trique luz","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Cr√©e une nouvelle m√©trique luz  üåê  Creates a new luz metric ‚Äî luz_metric","text":"","code":"luz_metric(   name = NULL,   ...,   private = NULL,   active = NULL,   parent_env = parent.frame(),   inherit = NULL )"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cr√©e une nouvelle m√©trique luz  üåê  Creates a new luz metric ‚Äî luz_metric","text":"name string naming new metric. ... named list public methods. implement least initialize, update compute. See details section information. private optional list private members, can functions non-functions. active optional list active binding functions. parent_env environment use parent newly-created objects. inherit R6ClassGenerator object inherit ; words, superclass. captured unevaluated expression evaluated parent_env time object instantiated.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Cr√©e une nouvelle m√©trique luz  üåê  Creates a new luz metric ‚Äî luz_metric","text":"Renvoie la nouvelle m√©trique luz.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric.html","id":"d-tails","dir":"Reference","previous_headings":"","what":"D√©tails","title":"Cr√©e une nouvelle m√©trique luz  üåê  Creates a new luz metric ‚Äî luz_metric","text":"Pour impl√©menter un nouveau luz_metric, il faut impl√©menter 3 m√©thodes: initialize: d√©finit l'√©tat initial de la m√©trique. Cette fonction est appel√©e pour chaque √©poque dans les boucles d'entra√Ænement et de validation. update: met √† jour l'√©tat interne de la m√©trique. Cette fonction est appel√©e √† chaque √©tape d'entra√Ænement et de validation avec les pr√©dictions obtenues par le mod√®le et les valeurs cibles obtenues √† partir du chargeur de donn√©e. compute: utilise l'√©tat interne pour calculer les valeurs du m√©trique. Cette fonction est appel√©e chaque fois que nous devons obtenir la valeur actuelle du m√©trique. Eg, elle est appel√©e chaque √©tape d'entra√Ænement pour les m√©triques affich√©es dans la bare de progression, mais uniquement appel√©e une fois par √©poque pour enregistrer sa valeur lorsque la bare de progression n'est pas affich√©e. Optionnellement, vous pouvez impl√©menter un champ abbrev qui donne √† la m√©trique un abr√©g√© que l'utilisera lors de l'  affichage d'informations sur les m√©triques dans le console ou enregistrer. Si aucun abbrev n'est pass√©, le nom de classe sera utilis√©. Voyons comment impl√©menter luz_metric_accuracy pour voir comment impl√©menter une nouvelle m√©trique:   strongNote : Il est recommand√© que le m√©trique compute renvoie des valeurs r√©guli√®res R au lieu de tenseurs torch car c'est ce qui est attendu par les autres parties de luz.","code":"luz_metric_accuracy <- luz_metric(  # Un abr√©g√© √† afficher dans les barreaux de progression, ou n# lorsque l'on imprime la progression   abbrev = \"Acc\",   # Configuration initiale pour le m√©trique. Les m√©triques sont initialis√©es   # √† chaque √©poque, pour les boucles d'entra√Ænement et de validation   initialize = function() {     self$correct <- 0     self$total <- 0   },  # Ex√©cuter √† chaque √©tape d'entra√Ænement ou de validation et mettre √† jour  # l'√©tat interne. La fonction update prend `preds` et `target` en param√®tres.  update = function(preds, target) {     pred <- torch::torch_argmax(preds, dim = 2)  self$correct <- self$correct + (pred == target)$       to(dtype = torch::torch_float())$  sum()$       item()        self$total <- self$total + pred$numel()   },  # Utiliser l'√©tat interne pour interroger la valeur du m√©trique   compute = function() {  self$correct/self$total   } )"},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Exemples","title":"Cr√©e une nouvelle m√©trique luz  üåê  Creates a new luz metric ‚Äî luz_metric","text":"","code":"luz_metric_accuracy <- luz_metric(   # An abbreviation to be shown in progress bars, or   # when printing progress   abbrev = \"Acc\",   # Initial setup for the metric. Metrics are initialized   # every epoch, for both training and validation   initialize = function() {     self$correct <- 0     self$total <- 0   },   # Run at every training or validation step and updates   # the internal state. The update function takes `preds`   # and `target` as parameters.   update = function(preds, target) {     pred <- torch::torch_argmax(preds, dim = 2)     self$correct <- self$correct + (pred == target)$       to(dtype = torch::torch_float())$       sum()$       item()     self$total <- self$total + pred$numel()   },   # Use the internal state to query the metric value   compute = function() {     self$correct/self$total   } ) #> Error in luz_metric(abbrev = \"Acc\", initialize = function() {    self$correct <- 0    self$total <- 0}, update = function(preds, target) {    pred <- torch::torch_argmax(preds, dim = 2)    self$correct <- self$correct + (pred == target)$to(dtype = torch::torch_float())$sum()$item()    self$total <- self$total + pred$numel()}, compute = function() {    self$correct/self$total}): impossible de trouver la fonction \"luz_metric\""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_accuracy.html","id":null,"dir":"Reference","previous_headings":"","what":"Pr√©cision (accuracy)  üåê  Accuracy ‚Äî luz_metric_accuracy","title":"Pr√©cision (accuracy)  üåê  Accuracy ‚Äî luz_metric_accuracy","text":"Calcule la pr√©cision (accuracy) pour les probl√®mes de classification multi-classes.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_accuracy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Pr√©cision (accuracy)  üåê  Accuracy ‚Äî luz_metric_accuracy","text":"","code":"luz_metric_accuracy()"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_accuracy.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Pr√©cision (accuracy)  üåê  Accuracy ‚Äî luz_metric_accuracy","text":"Renvoie la nouvelle m√©trique luz.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_accuracy.html","id":"d-tails","dir":"Reference","previous_headings":"","what":"D√©tails","title":"Pr√©cision (accuracy)  üåê  Accuracy ‚Äî luz_metric_accuracy","text":"Cette m√©trique s'attend √† des logits ou des probabilit√©s √† chaque mise √† jour. Elle prend alors l'argmax par colonne et le compare √† la variable cible.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_accuracy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Exemples","title":"Pr√©cision (accuracy)  üåê  Accuracy ‚Äî luz_metric_accuracy","text":"","code":"if (torch::torch_is_installed()) { library(torch) metric <- luz_metric_accuracy() metric <- metric$new() metric$update(torch_randn(100, 10), torch::torch_randint(1, 10, size = 100)) metric$compute() } #> Error in luz_metric_accuracy(): impossible de trouver la fonction \"luz_metric_accuracy\""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_binary_accuracy.html","id":null,"dir":"Reference","previous_headings":"","what":"Pr√©cision binaire  üåê  Binary accuracy ‚Äî luz_metric_binary_accuracy","title":"Pr√©cision binaire  üåê  Binary accuracy ‚Äî luz_metric_binary_accuracy","text":"Calcule la pr√©cision pour les probl√®mes de classification binaire pour un mod√®le avec des probabilit√©s en sortie. Le plus souvent, associ√© √† torch::nn_bce_loss().","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_binary_accuracy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Pr√©cision binaire  üåê  Binary accuracy ‚Äî luz_metric_binary_accuracy","text":"","code":"luz_metric_binary_accuracy(threshold = 0.5)"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_binary_accuracy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pr√©cision binaire  üåê  Binary accuracy ‚Äî luz_metric_binary_accuracy","text":"threshold valeur de seuil pour classifier les observations en 0 ou 1.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_binary_accuracy.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Pr√©cision binaire  üåê  Binary accuracy ‚Äî luz_metric_binary_accuracy","text":"Renvoie la nouvelle m√©trique luz.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_binary_accuracy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Exemples","title":"Pr√©cision binaire  üåê  Binary accuracy ‚Äî luz_metric_binary_accuracy","text":"","code":"if (torch::torch_is_installed()) { library(torch) metric <- luz_metric_binary_accuracy(threshold = 0.5) metric <- metric$new() metric$update(torch_rand(100), torch::torch_randint(0, 1, size = 100)) metric$compute() } #> Error in luz_metric_binary_accuracy(threshold = 0.5): impossible de trouver la fonction \"luz_metric_binary_accuracy\""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_binary_accuracy_with_logits.html","id":null,"dir":"Reference","previous_headings":"","what":"Pr√©cision binaire avec logits  üåê  Binary accuracy with logits ‚Äî luz_metric_binary_accuracy_with_logits","title":"Pr√©cision binaire avec logits  üåê  Binary accuracy with logits ‚Äî luz_metric_binary_accuracy_with_logits","text":"Calcule la pr√©cision (accuracy) pour les probl√®mes de classification binaire pour un mod√®le avec des logits en sortie. Le plus souvent, associ√© √† torch::nn_bce_with_logits_loss().","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_binary_accuracy_with_logits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Pr√©cision binaire avec logits  üåê  Binary accuracy with logits ‚Äî luz_metric_binary_accuracy_with_logits","text":"","code":"luz_metric_binary_accuracy_with_logits(threshold = 0.5)"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_binary_accuracy_with_logits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pr√©cision binaire avec logits  üåê  Binary accuracy with logits ‚Äî luz_metric_binary_accuracy_with_logits","text":"threshold valeur de seuil pour classifier les observations en 0 ou 1.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_binary_accuracy_with_logits.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Pr√©cision binaire avec logits  üåê  Binary accuracy with logits ‚Äî luz_metric_binary_accuracy_with_logits","text":"Renvoie la nouvelle m√©trique luz.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_binary_accuracy_with_logits.html","id":"d-tails","dir":"Reference","previous_headings":"","what":"D√©tails","title":"Pr√©cision binaire avec logits  üåê  Binary accuracy with logits ‚Äî luz_metric_binary_accuracy_with_logits","text":"Les probabilit√©s sont calcull√©es avec torch::nnf_sigmoid() et le threshold permet de classifier en 0 ou 1.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_binary_accuracy_with_logits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Exemples","title":"Pr√©cision binaire avec logits  üåê  Binary accuracy with logits ‚Äî luz_metric_binary_accuracy_with_logits","text":"","code":"if (torch::torch_is_installed()) { library(torch) metric <- luz_metric_binary_accuracy_with_logits(threshold = 0.5) metric <- metric$new() metric$update(torch_randn(100), torch::torch_randint(0, 1, size = 100)) metric$compute() } #> Error in luz_metric_binary_accuracy_with_logits(threshold = 0.5): impossible de trouver la fonction \"luz_metric_binary_accuracy_with_logits\""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_binary_auroc.html","id":null,"dir":"Reference","previous_headings":"","what":"Calcule la surface sous la courbe de ROC  üåê  Computes the area under the ROC ‚Äî luz_metric_binary_auroc","title":"Calcule la surface sous la courbe de ROC  üåê  Computes the area under the ROC ‚Äî luz_metric_binary_auroc","text":"Pour √©viter de stocker toutes les pr√©dictions et les valeurscibles pour une √©poque, nous calculons des matrices de confusion sur une plage de seuils √©tablis √† l'avance.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_binary_auroc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Calcule la surface sous la courbe de ROC  üåê  Computes the area under the ROC ‚Äî luz_metric_binary_auroc","text":"","code":"luz_metric_binary_auroc(   num_thresholds = 200,   thresholds = NULL,   from_logits = FALSE )"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_binary_auroc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calcule la surface sous la courbe de ROC  üåê  Computes the area under the ROC ‚Äî luz_metric_binary_auroc","text":"num_thresholds Nombre de seuils utilis√©s pour calculer les matrices de confusion. Lorsqu'utilis√©s, les seuils sont cr√©√©s en prenant num_thresholds valeurs lin√©airement espac√©es sur l'intervale [0, 1]. thresholds (facultatif) Si des seuils sont fournis, alors ceux-ci sont utilis√©s pour calculer les matrices de confusion et le param√®tre num_thresholds est ignor√©. from_logits Bool√©en indiquant si les pr√©dictions sont des logits, dans ce cas nous utilisons la fonction sigmoid pour les placer dans l'intervalle [0, 1].","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_binary_auroc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Exemples","title":"Calcule la surface sous la courbe de ROC  üåê  Computes the area under the ROC ‚Äî luz_metric_binary_auroc","text":"","code":"if (torch::torch_is_installed()){ library(torch) actual <- c(1, 1, 1, 0, 0, 0) predicted <- c(0.9, 0.8, 0.4, 0.5, 0.3, 0.2)  y_true <- torch_tensor(actual) y_pred <- torch_tensor(predicted)  m <- luz_metric_binary_auroc(thresholds = predicted) m <- m$new()  m$update(y_pred[1:2], y_true[1:2]) m$update(y_pred[3:4], y_true[3:4]) m$update(y_pred[5:6], y_true[5:6])  m$compute() } #> Error in luz_metric_binary_auroc(thresholds = predicted): impossible de trouver la fonction \"luz_metric_binary_auroc\""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_mae.html","id":null,"dir":"Reference","previous_headings":"","what":"Erreur absolue moyenne  üåê  Mean absolute error ‚Äî luz_metric_mae","title":"Erreur absolue moyenne  üåê  Mean absolute error ‚Äî luz_metric_mae","text":"Calcule l'erreur absolue moyenne.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_mae.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Erreur absolue moyenne  üåê  Mean absolute error ‚Äî luz_metric_mae","text":"","code":"luz_metric_mae()"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_mae.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Erreur absolue moyenne  üåê  Mean absolute error ‚Äî luz_metric_mae","text":"Renvoie la nouvelle m√©trique luz.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_mae.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Exemples","title":"Erreur absolue moyenne  üåê  Mean absolute error ‚Äî luz_metric_mae","text":"","code":"if (torch::torch_is_installed()) { library(torch) metric <- luz_metric_mae() metric <- metric$new() metric$update(torch_randn(100), torch_randn(100)) metric$compute() } #> Error in luz_metric_mae(): impossible de trouver la fonction \"luz_metric_mae\""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_mse.html","id":null,"dir":"Reference","previous_headings":"","what":"Erreur quadratique moyenne (MSE)  üåê  Mean squared error ‚Äî luz_metric_mse","title":"Erreur quadratique moyenne (MSE)  üåê  Mean squared error ‚Äî luz_metric_mse","text":"Calcule l'erreur quadratique moyenne (MSE).","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_mse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Erreur quadratique moyenne (MSE)  üåê  Mean squared error ‚Äî luz_metric_mse","text":"","code":"luz_metric_mse()"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_mse.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Erreur quadratique moyenne (MSE)  üåê  Mean squared error ‚Äî luz_metric_mse","text":"Renvoie la nouvelle m√©trique luz.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_multiclass_auroc.html","id":null,"dir":"Reference","previous_headings":"","what":"Calcule la surface sour la courbe de ROC dans le cas multi-classe.  üåê  Computes the multi-class AUROC ‚Äî luz_metric_multiclass_auroc","title":"Calcule la surface sour la courbe de ROC dans le cas multi-classe.  üåê  Computes the multi-class AUROC ‚Äî luz_metric_multiclass_auroc","text":"La d√©finition de  Keras est utilis√©e par d√©faut. Cela √©quivaut √† la m√©thode 'micro' dans SciKit Learn. Voir docs.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_multiclass_auroc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Calcule la surface sour la courbe de ROC dans le cas multi-classe.  üåê  Computes the multi-class AUROC ‚Äî luz_metric_multiclass_auroc","text":"","code":"luz_metric_multiclass_auroc(   num_thresholds = 200,   thresholds = NULL,   from_logits = FALSE,   average = c(\"micro\", \"macro\", \"weighted\", \"none\") )"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_multiclass_auroc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calcule la surface sour la courbe de ROC dans le cas multi-classe.  üåê  Computes the multi-class AUROC ‚Äî luz_metric_multiclass_auroc","text":"num_thresholds Nombre de seuils utilis√©s pour calculer les matrices de confusion. Lorsqu'utilis√©s, les seuils sont cr√©√©s en prenant num_thresholds valeurs lin√©airement espac√©es sur l'intervale [0, 1]. thresholds (facultatif) Si des seuils sont fournis, alors ceux-ci sont utilis√©s pour calculer les matrices de confusion et le param√®tre num_thresholds est ignor√©. from_logits Si TRUE alors nous appliquons torch::nnf_softmax() sur les predictions avant le calcul de la m√©trique. average La m√©thode pour moyenner : 'micro' : Empile toutes les classes et calcule l'AUC comme si c'√©tait un probl√®me de classification binaire. 'macro' : Trouve l'AUC pour chaque classe et calcule leur moyenne. 'weighted' : Trouve l'AUC pour chaque classe et calcule leur moyenne pond√©r√© en fonction du nombre d'instances pour chaque classe. 'none' : Retourne l'AUC pour chaque classe dans une liste.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_multiclass_auroc.html","id":"d-tails","dir":"Reference","previous_headings":"","what":"D√©tails","title":"Calcule la surface sour la courbe de ROC dans le cas multi-classe.  üåê  Computes the multi-class AUROC ‚Äî luz_metric_multiclass_auroc","text":"Notez que le d√©s√©quilibre des classes peut affecter cette m√©trique, contrairement √† l'AUC pour une classification binaire.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_multiclass_auroc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Exemples","title":"Calcule la surface sour la courbe de ROC dans le cas multi-classe.  üåê  Computes the multi-class AUROC ‚Äî luz_metric_multiclass_auroc","text":"","code":"if (torch::torch_is_installed()) { library(torch) actual <- c(1, 1, 1, 0, 0, 0) + 1L predicted <- c(0.9, 0.8, 0.4, 0.5, 0.3, 0.2) predicted <- cbind(1-predicted, predicted)  y_true <- torch_tensor(as.integer(actual)) y_pred <- torch_tensor(predicted)  m <- luz_metric_multiclass_auroc(thresholds = as.numeric(predicted),                                  average = \"micro\") m <- m$new()  m$update(y_pred[1:2,], y_true[1:2]) m$update(y_pred[3:4,], y_true[3:4]) m$update(y_pred[5:6,], y_true[5:6]) m$compute() } #> Error in luz_metric_multiclass_auroc(thresholds = as.numeric(predicted),     average = \"micro\"): impossible de trouver la fonction \"luz_metric_multiclass_auroc\""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_rmse.html","id":null,"dir":"Reference","previous_headings":"","what":"Erreur quadratique moyenne (RMSE)  üåê  Root mean squared error ‚Äî luz_metric_rmse","title":"Erreur quadratique moyenne (RMSE)  üåê  Root mean squared error ‚Äî luz_metric_rmse","text":"Calcule l'erreur quadratique moyenne (RMSE).","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_rmse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Erreur quadratique moyenne (RMSE)  üåê  Root mean squared error ‚Äî luz_metric_rmse","text":"","code":"luz_metric_rmse()"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_rmse.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Erreur quadratique moyenne (RMSE)  üåê  Root mean squared error ‚Äî luz_metric_rmse","text":"Renvoie la nouvelle m√©trique luz.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Cr√©e un ensemble de m√©triques  üåê  Creates a metric set ‚Äî luz_metric_set","title":"Cr√©e un ensemble de m√©triques  üåê  Creates a metric set ‚Äî luz_metric_set","text":"Un ensemble de m√©triques √† utiliser pour specifier les m√©triques √† utiliser pendant l'entra√Ænement, l'√©valuation, ou les deux.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Cr√©e un ensemble de m√©triques  üåê  Creates a metric set ‚Äî luz_metric_set","text":"","code":"luz_metric_set(metrics = NULL, train_metrics = NULL, valid_metrics = NULL)"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_metric_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cr√©e un ensemble de m√©triques  üåê  Creates a metric set ‚Äî luz_metric_set","text":"metrics Une liste de luz_metrics √† utiliser pour l'entra√Ænement et la validation train_metrics Une liste de luz_metrics √† utiliser seulement pour l'entra√Ænement valid_metrics Une liste de luz_metrics √† utiliser seulement pour la validation","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_save.html","id":null,"dir":"Reference","previous_headings":"","what":"Enregistre in objet luz sur disque  üåê  Saves luz objects to disk ‚Äî luz_save","title":"Enregistre in objet luz sur disque  üåê  Saves luz objects to disk ‚Äî luz_save","text":"originalAllows saving luz fitted models disk. Objects can loaded back luz_load().  translationAllows saving luz fitted models disk. Objects can loaded back luz_load().","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_save.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Enregistre in objet luz sur disque  üåê  Saves luz objects to disk ‚Äî luz_save","text":"","code":"luz_save(obj, path, ...)"},{"path":"https://cregouby.github.io/luz.fr/reference/luz_save.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enregistre in objet luz sur disque  üåê  Saves luz objects to disk ‚Äî luz_save","text":"obj Un objet de classe 'luz_module_fitted', r√©sultat de fit.luz_module_generator(). path path file system save object. ... inutilis√©","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_save.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Enregistre in objet luz sur disque  üåê  Saves luz objects to disk ‚Äî luz_save","text":"Les objets sont sauvegard√©s au format .rds, mais le obj$model est d'abord s√©rialis√© avec torch_save avant cela.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/luz_save.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Enregistre in objet luz sur disque  üåê  Saves luz objects to disk ‚Äî luz_save","text":"L'objet ctx est s√©rialis√© naivement, c-√†-d. que utilise saveRDS()directement pour le s√©rialiser. Ne comptez pas sur luz_save pour des objet non s√©rialisables dans le ctx comme des torch_tensors ou des pointeurs externes en g√©n√©ral.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/nn_mixup_loss.html","id":null,"dir":"Reference","previous_headings":"","what":"Fonction de co√ªt √† utiliser avec callbacks_mixup().  üåê  Loss to be used with callbacks_mixup(). ‚Äî nn_mixup_loss","title":"Fonction de co√ªt √† utiliser avec callbacks_mixup().  üåê  Loss to be used with callbacks_mixup(). ‚Äî nn_mixup_loss","text":"Pendant la phase d'entra√Ænement, calcule la fonction de co√ªt par rapport √† deux cibles individuelles, leur alloue chacune un poids et les combine lin√©airement pour obtenir la perte moyenne du lot. Pour la validation et le test, se r√©f√®re au tenseur de perte pass√©.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/nn_mixup_loss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Fonction de co√ªt √† utiliser avec callbacks_mixup().  üåê  Loss to be used with callbacks_mixup(). ‚Äî nn_mixup_loss","text":"","code":"nn_mixup_loss(loss)"},{"path":"https://cregouby.github.io/luz.fr/reference/nn_mixup_loss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fonction de co√ªt √† utiliser avec callbacks_mixup().  üåê  Loss to be used with callbacks_mixup(). ‚Äî nn_mixup_loss","text":"loss Le fonction de co√ªt sous-jacente de nn_module √† appeler. Elle doit supporter le champ reduction. Pendant l'entra√Ænement, l'attribut sera modifi√© en 'none' afin que nous obtenions le co√ªt pour les observations individuelles. Voir par exemple la documentation du champ reduction dans torch::nn_cross_entropy_loss().","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/nn_mixup_loss.html","id":"d-tails","dir":"Reference","previous_headings":"","what":"D√©tails","title":"Fonction de co√ªt √† utiliser avec callbacks_mixup().  üåê  Loss to be used with callbacks_mixup(). ‚Äî nn_mixup_loss","text":"Doit √™tre utilis√© simultan√©ment avec luz_callback_mixup().","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/nnf_mixup.html","id":null,"dir":"Reference","previous_headings":"","what":"Logique de m√©lange  üåê  Mixup logic ‚Äî nnf_mixup","title":"Logique de m√©lange  üåê  Mixup logic ‚Äî nnf_mixup","text":"La logique sous-jacente √† luz_callback_mixup().","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/nnf_mixup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Logique de m√©lange  üåê  Mixup logic ‚Äî nnf_mixup","text":"","code":"nnf_mixup(x, y, weight)"},{"path":"https://cregouby.github.io/luz.fr/reference/nnf_mixup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logique de m√©lange  üåê  Mixup logic ‚Äî nnf_mixup","text":"x un lot des variables d'entr√©es y un lot des variables cible weight les coefficients de pond√©ration √† utiliser avec torch_lerp()","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/nnf_mixup.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Logique de m√©lange  üåê  Mixup logic ‚Äî nnf_mixup","text":"Une liste contenant : x, le nouveau lot d'entr√©es m√©lang√© y, une liste contenant : ys, une liste contenant : y1, la cible originale y1 y2, la cible m√©lang√©e y2 weight, les poids de m√©lange","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/nnf_mixup.html","id":"d-tails","dir":"Reference","previous_headings":"","what":"D√©tails","title":"Logique de m√©lange  üåê  Mixup logic ‚Äî nnf_mixup","text":"Sur la base des lots d'entr√©es et de cibles pass√©s en argument, ainsi que des poids de m√©lange appropri√©s, la fonction remplace le lot actuel par de nouveaux tenseurs. Le nouveau lot d'entr√©es est une combinaison lin√©aire pond√©r√©e des √©l√©ments du lot d'entr√©es initial, tandis que le nouveau lot de cibles rassemble les cibles originales, ainsi que les poids de m√©lange, dans une liste imbriqu√©e.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/nnf_mixup.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Exemples","title":"Logique de m√©lange  üåê  Mixup logic ‚Äî nnf_mixup","text":"","code":"if (torch::torch_is_installed()) { batch_x <- torch::torch_randn(c(10, 768)) batch_y <- torch::torch_randn(10) weight <- torch::torch_tensor(rep(0.9, 10))$view(c(10, 1)) nnf_mixup(batch_x, batch_y, weight) } #> Error in nnf_mixup(batch_x, batch_y, weight): impossible de trouver la fonction \"nnf_mixup\""},{"path":"https://cregouby.github.io/luz.fr/reference/predict.luz_module_fitted.html","id":null,"dir":"Reference","previous_headings":"","what":"Cr√©e des pr√©dictions pour un mod√®le entra√Æn√©  üåê  Create predictions for a fitted model ‚Äî predict.luz_module_fitted","title":"Cr√©e des pr√©dictions pour un mod√®le entra√Æn√©  üåê  Create predictions for a fitted model ‚Äî predict.luz_module_fitted","text":"Cr√©e des pr√©dictions pour un mod√®le entra√Æn√©","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/predict.luz_module_fitted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Cr√©e des pr√©dictions pour un mod√®le entra√Æn√©  üåê  Create predictions for a fitted model ‚Äî predict.luz_module_fitted","text":"","code":"# M√©thode S3 pour la classe luz_module_fitted predict(   object,   newdata,   ...,   callbacks = list(),   accelerator = NULL,   verbose = NULL,   dataloader_options = NULL )"},{"path":"https://cregouby.github.io/luz.fr/reference/predict.luz_module_fitted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cr√©e des pr√©dictions pour un mod√®le entra√Æn√©  üåê  Create predictions for a fitted model ‚Äî predict.luz_module_fitted","text":"object L'objet mod√®le entra√Æn√© retourn√© par fit.luz_module_generator() newdata (dataloader, dataset, liste ou tableau) renvoyant une liste avec au moins un √©l√©ment. Les autres √©l√©ments ne sont pas utilis√©s. ... Inutilis√© callbacks (liste, optionnel) Une liste d'appels de callback d√©finis avec luz_callback() qui seront appel√©s pendant la proc√©dure d'entra√Ænement. Les appels de callback luz_callback_metrics(), luz_callback_progress() et luz_callback_train_valid() sont toujours ajout√©s par d√©faut. accelerator (acc√©l√©rateur, optionnel) Un objet d'acc√©l√©rateur accelerator() utilis√© pour configurer l'emplacement du calcul des composants tels que les nn_modules, les optimiseurs et les lots de donn√©es. verbose (bool√©en, optionnel) La proc√©dure d'entra√Ænement doit-elle √©mettre des messages vers la console pendant l'entra√Ænement. Par d√©faut, elle produira des messages si interactive() est TRUE. dataloader_options Options utilis√©es lors de la cr√©ation d'un chargeur de donn√©e. Voir torch::dataloader(). shuffle=TRUE par d√©faut pour les donn√©es d'entra√Ænement et batch_size=32 par d√©faut. Il produira une erreur si ce n'est pas NULL et que data est d√©j√† un chargeur de donn√©e.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objets export√©s des autres paquets  üåê  Objects exported from other packages ‚Äî reexports","title":"Objets export√©s des autres paquets  üåê  Objects exported from other packages ‚Äî reexports","text":"Ces objects sont import√©s d'autres paquets. Suivez les liens suivants pour consulter leur documentation. generics fit","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/set_hparams.html","id":null,"dir":"Reference","previous_headings":"","what":"D√©finit les hyper-param√®tres d'un module  üåê  Set hyper-parameter of a module ‚Äî set_hparams","title":"D√©finit les hyper-param√®tres d'un module  üåê  Set hyper-parameter of a module ‚Äî set_hparams","text":"Cette fonction est utilis√©e pour d√©finir les hyper-param√®tres avant d'appeler fit pour les luz_modules.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/set_hparams.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"D√©finit les hyper-param√®tres d'un module  üåê  Set hyper-parameter of a module ‚Äî set_hparams","text":"","code":"set_hparams(module, ...)"},{"path":"https://cregouby.github.io/luz.fr/reference/set_hparams.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"D√©finit les hyper-param√®tres d'un module  üåê  Set hyper-parameter of a module ‚Äî set_hparams","text":"module Un nn_module apr√®s son initialisation par setup(). ... Les param√®tres d√©finis ici seront utilis√©s pour initialiser le nn_module, c'est-√†-dire qu'ils seront pass√©s tels quels √† la m√©thode initialize du nn_module de base.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/set_hparams.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"D√©finit les hyper-param√®tres d'un module  üåê  Set hyper-parameter of a module ‚Äî set_hparams","text":"Le m√™me module luz","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/set_opt_hparams.html","id":null,"dir":"Reference","previous_headings":"","what":"D√©finit les hyper-param√®tres de l'optimiseur  üåê  Set optimizer hyper-parameters ‚Äî set_opt_hparams","title":"D√©finit les hyper-param√®tres de l'optimiseur  üåê  Set optimizer hyper-parameters ‚Äî set_opt_hparams","text":"Cette fonction est utilis√©e pour d√©finir les hyper-param√®tres √† l'initialisation de l'optimiseur.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/set_opt_hparams.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"D√©finit les hyper-param√®tres de l'optimiseur  üåê  Set optimizer hyper-parameters ‚Äî set_opt_hparams","text":"","code":"set_opt_hparams(module, ...)"},{"path":"https://cregouby.github.io/luz.fr/reference/set_opt_hparams.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"D√©finit les hyper-param√®tres de l'optimiseur  üåê  Set optimizer hyper-parameters ‚Äî set_opt_hparams","text":"module Un nn_module apr√®s son initialisation par setup(). ... Les param√®tres pass√©s ici seront utilis√©s pour initialiser les optimiseurs. Par exemple, si votre optimiseur est optim_adam et vous passez lr=0.1, alors la fonction  optim_adam est appel√©e avec optim_adam(parameters, lr=0.1) lors de l'entra√Ænement du mod√®le.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/set_opt_hparams.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"D√©finit les hyper-param√®tres de l'optimiseur  üåê  Set optimizer hyper-parameters ‚Äî set_opt_hparams","text":"m√™me module luz","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/reference/setup.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialise l'usage d'un nn_module avec luz  üåê  Set's up a nn_module to use with luz ‚Äî setup","title":"Initialise l'usage d'un nn_module avec luz  üåê  Set's up a nn_module to use with luz ‚Äî setup","text":"La fonction d'initialiation, utilis√©e pour d√©finir les attributs et les m√©thodes importantes pour que le nn_modules fonctionne avec luz.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/setup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Utilisation","title":"Initialise l'usage d'un nn_module avec luz  üåê  Set's up a nn_module to use with luz ‚Äî setup","text":"","code":"setup(module, loss = NULL, optimizer = NULL, metrics = NULL, backward = NULL)"},{"path":"https://cregouby.github.io/luz.fr/reference/setup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialise l'usage d'un nn_module avec luz  üåê  Set's up a nn_module to use with luz ‚Äî setup","text":"module (nn_module) Le nn_module √† utiliser. loss (fonction, optionnel) Une fonction avec la signature function(input, target). Elle est uniquement requise si votre  nn_module n'impl√©mente pas une fonction de co√ªt nom√©e loss. optimizer (optimiseur torch, optionnel) Une fonction avec la signature function(parameters, ...) qui est utilis√©e pour initialiser un optimiseur √† partir des param√®tres du mod√®le. metrics (liste, optionnel) Une liste de m√©triques √† suivre pendant la proc√©dure d'entra√Ænement. Si vous voulez que des m√©triques soient √©valu√©es uniquement pendant l'entra√Ænement ou la validation, vous pouvez passer un objet luz_metric_set() pour sp√©cifier les m√©triques utilis√©es √† chaque √©tape. backward (fonction) Une fonction qui prend des valeurs retourn√©es par la fonction de co√ªt comme param√®tres. Elle doit appeler $backward() ou torch::autograd_backward(). En g√©n√©ral, vous n'avez pas besoin de d√©finir ce param√®tre sauf si vous devez personnaliser comment luz appelle la m√©thode backward(), par exemple, si vous devez ajouter des arguments suppl√©mentaires √† l'appel de la m√©thode. Notez que cela devient une m√©thode du nn_module, donc elle peut √™tre utilis√©e par votre step() personnalis√© si vous le red√©finissez.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/setup.html","id":"valeur-de-retour","dir":"Reference","previous_headings":"","what":"Valeur de retour","title":"Initialise l'usage d'un nn_module avec luz  üåê  Set's up a nn_module to use with luz ‚Äî setup","text":"Un module luz qui peut √™tre entra√Æn√© avec fit().","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/setup.html","id":"d-tails","dir":"Reference","previous_headings":"","what":"D√©tails","title":"Initialise l'usage d'un nn_module avec luz  üåê  Set's up a nn_module to use with luz ‚Äî setup","text":"Elle s'assure que le module ait tous les ingr√©dients n√©cessaires pour √™tre entra√Æn√©.","code":""},{"path":"https://cregouby.github.io/luz.fr/reference/setup.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Initialise l'usage d'un nn_module avec luz  üåê  Set's up a nn_module to use with luz ‚Äî setup","text":"Elle ajoute √©galement un champ de device actif qui peut √™tre utilis√© pour interroger le device courant du module dans les m√©thodes, comme par exemple self$device. Cela est utile lorsque ctx() n'est pas disponible, par exemple, lorsque vous appelez des m√©thodes en dehors de luz. Les utilisateurs peuvent personnaliser la valeur par d√©faut en impl√©mentant une m√©thode active de device dans le module d'entr√©e.","code":""},{"path":[]},{"path":"https://cregouby.github.io/luz.fr/news/index.html","id":"luzfr-040","dir":"Changelog","previous_headings":"","what":"luz.fr 0.4.0","title":"luz.fr 0.4.0","text":"Initial function help translation.","code":""},{"path":"https://cregouby.github.io/luz.fr/news/index.html","id":"luzfr-049002","dir":"Changelog","previous_headings":"","what":"luz.fr 0.4.9002","title":"luz.fr 0.4.9002","text":"Vignettes translation pkgdown publication github page. add function reference translation github page","code":""}]
